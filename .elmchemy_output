
>>>>elm/Hello.elm
module Hello exposing (..)


{-| Prints "world!"

    hello == "world!"
-}
hello : String
hello =
    "world!"
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XBasics.elm
module Elmchemy.XBasics
    exposing
        ( Order(..)
        , compare
        , xor
        , negate
        , sqrt
        , clamp
        , logBase
        , e
        , pi
        , cos
        , sin
        , tan
        , acos
        , asin
        , atan
        , atan2
        , round
        , floor
        , ceiling
        , truncate
        , toFloat
        , toString
        , (++)
        , identity
        , always
        , flip
        , tuple2
        , tuple3
        , tuple4
        , tuple5
        )

{-| Tons of useful functions that get imported by default.
@docs compare, xor, sqrt, clamp, compare , xor , negate , sqrt , logBase , e , pi , cos , sin , tan , acos , asin , atan , atan2 , round , floor , ceiling , truncate , toFloat , toString , (++) , identity , always, flip, tuple2, tuple3, tuple4, tuple5

@docs Order

-}

import Elmchemy exposing (..)


{-| Represents the relative ordering of two things.
The relations are less than, equal to, and greater than.
-}
type Order
    = LT
    | EQ
    | GT



-- Operators
{- ex

   import Kernel, except: [
     {:'++', 2},
     {:round, 1},
     {:to_string, 1}

   ]

   curry ==/2
   curry !=/2
   curry </2
   curry >/2
   curry <=/2
   curry >=/2
   curry max/2
   curry min/2

   curry &&/2
   curry ||/2

   curry +/2
   curry -/2
   curry */2
   curry //2
   curry div/2
   curry rem/2
   curry abs/1
   # Inlined from not
   curry !/1

-}


{-| Basic compare function


### Example

    compare 1 2 == LT

-}
compare : comparable -> comparable -> Order
compare a b =
    if a > b then
        GT
    else if a < b then
        LT
    else
        EQ



{- ex
   # >> is replaced with >>> by the compiler
   def l >>> r do
     fn x -> r.(l.(x)) end
   end

-}
-- not/1 is inlined by the compiler


{-| The exclusive-or operator. `True` if exactly one input is `True`.
-}
xor : Bool -> Bool -> Bool
xor a b =
    (a && not b) || (not a && b)


{-| Negate a number.

    negate 42 == -42
    negate -42 == 42
    negate 0 == 0

-}
negate : number -> number
negate =
    ffi "Kernel" "-"


{-| Take the square root of a number.
-}
sqrt : number -> Float
sqrt =
    ffi ":math" "sqrt"


{-| Clamps a number within a given range. With the expression
`clamp 100 200 x` the results are as follows:
100 if x < 100
x if 100 <= x < 200
200 if 200 <= x
-}
clamp : comparable -> comparable -> comparable -> comparable
clamp x bottom top =
    x
        |> min bottom
        |> max top


{-| -}
logBase : Float -> Float -> Float
logBase a b =
    notImplemented


{-| -}
e : Float
e =
    2.71828


{-| -}
pi : Float
pi =
    ffi ":math" "pi"


{-| -}
cos : Float -> Float
cos =
    ffi ":math" "cos"


{-| -}
sin : Float -> Float
sin =
    ffi ":math" "sin"


{-| -}
tan : Float -> Float
tan =
    ffi ":math" "tan"


{-| -}
acos : Float -> Float
acos =
    ffi ":math" "acos"


{-| -}
asin : Float -> Float
asin =
    ffi ":math" "asin"


{-| -}
atan : Float -> Float
atan =
    ffi ":math" "atan"


{-| -}
atan2 : Float -> Float -> Float
atan2 =
    ffi ":math" "atan2"


{-| -}
round : Float -> Int
round =
    ffi "Kernel" "round"


{-| -}
floor : Float -> Int
floor x =
    notImplemented


{-| -}
ceiling : Float -> Int
ceiling x =
    notImplemented


{-| Truncate a number, rounding towards zero.
-}
truncate : Float -> Int
truncate x =
    notImplemented


{-| Convert an integer into a float.
-}
toFloat : Int -> Float
toFloat x =
    mul_ x 1.0


mul_ : Int -> Float -> Float
mul_ =
    ffi "Kernel" "*"


{-| Turn any kind of value into a string. When you view the resulting string
with `Text.fromString` it should look just like the value it came from.

    toString 42 == "42"
    toString [1,2] == "[1, 2]"

-}
toString : a -> String
toString a =
    inspect_ a []


type BinariesAs
    = AsBinaries
    | AsStrings


type InspectOption
    = Structs Bool
    | Binaries BinariesAs


inspect_ : a -> List InspectOption -> String
inspect_ =
    ffi "Kernel" "inspect"


{-| Put two appendable things together. This includes strings, lists, and text.

    "hello" ++ "world" == "helloworld"
    [1,1,2] ++ [3,5,8] == [1,1,2,3,5,8]

-}
(++) : appendable -> appendable -> appendable
(++) a b =
    if isBinary_ a && isBinary_ b then
        addStrings_ a b
    else
        addLists_ a b


isBinary_ : a -> Bool
isBinary_ =
    ffi "Kernel" "is_binary"



{- flag noverify:+addStrings_ -}


addStrings_ : appendable -> appendable -> appendable
addStrings_ =
    ffi "Kernel" "<>"



{- flag noverify:+addLists_ -}


addLists_ : appendable -> appendable -> appendable
addLists_ =
    ffi "Kernel" "++"


{-| Given a value, returns exactly the same value. This is called
[the identity function](http://en.wikipedia.org/wiki/Identity_function).
-}
identity : a -> a
identity a =
    a


{-| Create a function that *always* returns the same value. Useful with
functions like `map`:

    List.map (always 0) [1,2,3,4,5] == [0,0,0,0,0]
    List.map (\_ -> 0) [1,2,3,4,5] == [0,0,0,0,0]

-}
always : a -> a -> a
always a b =
    a


{-| Flip the order of the first two arguments to a function.
-}
flip : (a -> b -> c) -> b -> a -> c
flip f a b =
    f b a



-- TODO Will be fixed with #34
{- ex
   @spec curried(({any, any} -> any)) :: ((any -> any) -> any)
   curry curried/1
   def curried(fun) do
     fn fst -> fn snd -> fun.({fst, snd}) end end
   end

   @spec uncurried(((any -> any) -> any)) :: ({any, any} -> any)
   curry uncurried/1
   def uncurried(fun) do
     fn {fst, snd} -> fun.(fst).(snd) end
   end

-}
-- We don't care for Never type
-- Additional


notImplemented : a
notImplemented =
    let
        _ =
            throw_ "Not implemented"
    in
        Debug.crash "a"


throw_ : String -> ()
throw_ =
    ffi "Kernel" "throw"


{-| -}
tuple2 : a -> b -> ( a, b )
tuple2 a b =
    ( a, b )


{-| -}
tuple3 : a -> b -> c -> ( a, b, c )
tuple3 a b c =
    ( a, b, c )


{-| -}
tuple4 : a -> b -> c -> d -> ( a, b, c, d )
tuple4 a b c d =
    ( a, b, c, d )


{-| -}
tuple5 : a -> b -> c -> d -> e -> ( a, b, c, d, e )
tuple5 a b c d e =
    ( a, b, c, d, e )
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XChar.elm
module Elmchemy.XChar
    exposing
        ( isUpper
        , isLower
        , isDigit
        , isOctDigit
        , isHexDigit
        , toUpper
        , toLower
        , KeyCode
        , toCode
        , fromCode
        )

{-| Functions for working with characters. Character literals are enclosed in
`'a'` pair of single quotes.


# Classification

@docs isUpper, isLower, isDigit, isOctDigit, isHexDigit


# Conversion

@docs toUpper, toLower


# Key Codes

@docs KeyCode, toCode, fromCode

-}

import Elmchemy exposing (..)


{-| True for char between first and second argument

    between 'a' 'z' 'b' == True
    between '1' '9' '5' == True
    between 'A' 'Z' 'g' == False

-}
isBetween : Char -> Char -> Char -> Bool
isBetween low high char =
    let
        code =
            toCode char
    in
        (code >= toCode low) && (code <= toCode high)


{-| True for upper case ASCII letters.

    isUpper 'D' == True
    isUpper 'A' == True
    isUpper 'x' == False

-}
isUpper : Char -> Bool
isUpper char =
    isBetween 'A' 'Z' char


{-| True for lower case ASCII letters.

    isLower 'd' == True
    isLower 'a' == True
    isLower 'X' == False

-}
isLower : Char -> Bool
isLower char =
    isBetween 'a' 'z' char


{-| True for ASCII digits `[0-9]`.

    isDigit '1' == True
    isDigit '9' == True
    isDigit 'a' == False

-}
isDigit : Char -> Bool
isDigit char =
    isBetween '0' '9' char


{-| True for ASCII octal digits `[0-7]`.

    isOctDigit '7' == True
    isOctDigit '5' == True
    isOctDigit '9' == False

-}
isOctDigit : Char -> Bool
isOctDigit char =
    isBetween '0' '7' char


{-| True for ASCII hexadecimal digits `[0-9a-fA-F]`.

    isHexDigit 'd' == True
    isHexDigit 'D' == True
    isHexDigit 'x' == False

-}
isHexDigit : Char -> Bool
isHexDigit char =
    isDigit char || isBetween 'a' 'f' char || isBetween 'A' 'F' char


{-| Convert to upper case.

    toUpper 'a' == 'A'

-}
toUpper : Char -> Char
toUpper =
    ffi ":string" "to_upper"


{-| Convert to lower case.

    toLower 'A' == 'a'

-}
toLower : Char -> Char
toLower =
    ffi ":string" "to_lower"



-- {-| Convert to upper case, according to any locale-specific case mappings. -}
-- toLocaleUpper : Char -> Char
-- toLocaleUpper =
--   Native.Char.toLocaleUpper
-- {-| Convert to lower case, according to any locale-specific case mappings. -}
-- toLocaleLower : Char -> Char
-- toLocaleLower =
--   Native.Char.toLocaleLower


{-| Keyboard keys can be represented as integers. These are called *key codes*.
You can use [`toCode`](#toCode) and [`fromCode`](#fromCode) to convert between
key codes and characters.
-}
type alias KeyCode =
    Int



{- flag noverify:+toCode -}


{-| Convert to key code.

    toCode 'a' == 97

-}
toCode : Char -> KeyCode
toCode =
    ffi "Kernel" "hd"


{-| Convert from key code.

    fromCode 97 == 'a'

-}
fromCode : KeyCode -> Char
fromCode code =
    insert_at_ [] 0 code


insert_at_ : List a -> Int -> a -> Char
insert_at_ =
    ffi "List" "insert_at"
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XDebug.elm
module Elmchemy.XDebug
    exposing
        ( log
        , crash
        )

{-| Module with helper functions for debugging


# Debug

@docs log, crash

-}

import Elmchemy exposing (..)


{-| Log to console in `title: object` format
-}
log : String -> a -> a
log title a =
    let
        _ =
            puts_ "#{title}:#{a}" []
    in
        a


puts_ : a -> List ( key, val ) -> a
puts_ =
    ffi "IO" "inspect"



{- We don't verify since it's a macro -}
{- flag noverify:+crash -}


{-| Raise an exception to crash the runtime. Should be avoided at all
costs. Helpful for crashing at not yet implelented functionality
-}
crash : String -> a
crash =
    ffi "Kernel" "raise"
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XList.elm
module Elmchemy.XList
    exposing
        ( isEmpty
        , length
        , reverse
        , member
        , head
        , tail
        , filter
        , take
        , drop
        , singleton
        , repeat
        , range
        , cons
        , (::)
        , append
        , concat
        , intersperse
        , partition
        , unzip
        , map
        , map2
        , filterMap
        , concatMap
        , indexedMap
        , foldr
        , foldl
        , sum
        , product
        , maximum
        , minimum
        , all
        , any
        , scanl
        , sort
        , sortBy
        , sortWith
        )

{-| A library for manipulating lists of values. Every value in a
list must have the same type.


# Basics

@docs isEmpty, length, reverse, member


# Sub-lists

@docs head, tail, filter, take, drop


# Putting Lists Together

@docs singleton, repeat, range, cons, (::), append, concat, intersperse


# Taking Lists Apart

@docs partition, unzip


# Mapping

@docs map, map2

If you can think of a legitimate use of `mapN` where `N` is 6 or more, please
let us know on [the list](https://groups.google.com/forum/#!forum/elm-discuss).
The current sentiment is that it is already quite error prone once you get to
4 and possibly should be approached another way.


# Special Maps

@docs filterMap, concatMap, indexedMap


# Folding

@docs foldr, foldl


# Special Folds

@docs sum, product, maximum, minimum, all, any, scanl


# Sorting

@docs sort, sortBy, sortWith

-}

import Elmchemy exposing (..)


{- ex
   import Kernel, except: [{:length, 1}]
   import Elmchemy.XBasics
-}


{-| Add an element to the front of a list. Pronounced *cons*.

    1 :: [2,3] == [1,2,3]
    1 :: [] == [1]

-}



{- flag nodef:+:: nocurry:+:: nospec:+:: -}


(::) : a -> List a -> List a
(::) a list =
    cons a list


{-| Add an element to the front of a list. Pronounced *cons*.

    cons 1 [2,3] == [1,2,3]
    cons 1 [] == [1]

-}
cons : a -> List a -> List a
cons a list =
    a :: list


{-| Extract the first element of a list.

    head [1,2,3] == Just 1
    head [] == Nothing

-}
head : List a -> Maybe a
head list =
    case list of
        x :: xs ->
            Just x

        [] ->
            Nothing


{-| Extract the rest of the list.

    tail [1,2,3] == Just [2,3]
    tail [] == Nothing

-}
tail : List a -> Maybe (List a)
tail list =
    case list of
        x :: xs ->
            Just xs

        [] ->
            Nothing


{-| Determine if a list is empty.

    isEmpty [] == True

-}
isEmpty : List a -> Bool
isEmpty xs =
    case xs of
        [] ->
            True

        _ ->
            False


{-| Figure out whether a list contains a value.

    member 9 [1,2,3,4] == False
    member 4 [1,2,3,4] == True

-}
member : a -> List a -> Bool
member x xs =
    any (\a -> a == x) xs


{-| Apply a function to every element of a list.

    map sqrt [1,4,9] == [1.0,2.0,3.0]

    map not [True,False,True] == [False,True,False]

-}
map : (a -> b) -> List a -> List b
map f xs =
    foldr (\x acc -> f x :: acc) [] xs


{-| Same as `map` but the function is also applied to the index of each
element (starting at zero).

    indexedMap (,) ["Tom","Sue","Bob"] == [ (0,"Tom"), (1,"Sue"), (2,"Bob") ]

-}
indexedMap : (Int -> a -> b) -> List a -> List b
indexedMap f xs =
    map2 f (range 0 (length xs - 1)) xs


{-| Reduce a list from the left.

    foldl (::) [] [1,2,3] == [3,2,1]

-}
foldl : (a -> b -> b) -> b -> List a -> b
foldl func acc list =
    case list of
        [] ->
            acc

        x :: xs ->
            foldl func (func x acc) xs


{-| Reduce a list from the right.

    foldr (+) 0 [1,2,3] == 6

-}
foldr : (a -> b -> b) -> b -> List a -> b
foldr f start list =
    foldr_ list start f


foldr_ : List a -> b -> (a -> b -> b) -> b
foldr_ =
    ffi "List" "foldr"


{-| Reduce a list from the left, building up all of the intermediate results into a list.

    scanl (+) 0 [1,2,3,4] == [0,1,3,6,10]

-}
scanl : (a -> b -> b) -> b -> List a -> List b
scanl f b xs =
    let
        scan1 x accAcc =
            case accAcc of
                acc :: _ ->
                    f x acc :: accAcc

                [] ->
                    []
    in
        reverse (foldl scan1 [ b ] xs)


{-| Keep only elements that satisfy the predicate.

    filter (flip (%) 2 >> (==) 0) [1,2,3,4,5,6] == [2,4,6]

-}
filter : (a -> Bool) -> List a -> List a
filter pred xs =
    let
        conditionalCons front back =
            if pred front then
                front :: back
            else
                back
    in
        foldr conditionalCons [] xs


{-| Apply a function that may succeed to all values in the list, but only keep
the successes.

    filterMap (\a -> if a >= 18 then Just a else Nothing) [3, 15, 12, 18, 24] == [18, 24]

-}
filterMap : (a -> Maybe b) -> List a -> List b
filterMap f xs =
    foldr (maybeCons f) [] xs


maybeCons : (a -> Maybe b) -> a -> List b -> List b
maybeCons f mx xs =
    case f mx of
        Just x ->
            x :: xs

        Nothing ->
            xs


{-| Determine the length of a list.

    length [1,2,3] == 3

-}
length : List a -> Int
length xs =
    foldl (\_ i -> i + 1) 0 xs


{-| Reverse a list.

    reverse [1,2,3,4] == [4,3,2,1]

-}
reverse : List a -> List a
reverse list =
    foldl (::) [] list


{-| Determine if all elements satisfy the predicate.

    all (\a -> a % 2 == 0) [2,4] == True
    all (\a -> a % 2 == 0) [2,3] == False
    all (\a -> a % 2 == 0) [] == True

-}
all : (a -> Bool) -> List a -> Bool
all isOkay list =
    not (any (isOkay >> not) list)


{-| Determine if any elements satisfy the predicate.

    any (\a -> a % 2 == 0) [2,3] == True
    any (\a -> a % 2 == 0) [1,3] == False
    any (\a -> a % 2 == 0) [] == False

-}
any : (a -> Bool) -> List a -> Bool
any isOkay list =
    case list of
        [] ->
            False

        x :: xs ->
            if isOkay x then
                True
            else
                any isOkay xs


{-| Put two lists together.

    append [1,1,2] [3,5,8] == [1,1,2,3,5,8]
    append ['a','b'] ['c'] == ['a','b','c']

You can also use [the `(++)` operator](Basics#++) to append lists.

-}
append : List a -> List a -> List a
append xs ys =
    case ys of
        [] ->
            xs

        _ ->
            foldr (::) ys xs


{-| Concatenate a bunch of lists into a single list:

    concat [[1,2],[3],[4,5]] == [1,2,3,4,5]

-}
concat : List (List a) -> List a
concat lists =
    foldr append [] lists


{-| Map a given function onto a list and flatten the resulting lists.

    concatMap (range 2) [1] == concat (map (range 2) [1]) == true

-}
concatMap : (a -> List b) -> List a -> List b
concatMap f list =
    concat (map f list)


{-| Get the sum of the list elements.

    sum [1,2,3,4] == 10

-}
sum : List number -> number
sum numbers =
    foldl (+) 0 numbers


{-| Get the product of the list elements.

    product [1,2,3,4] == 24

-}
product : List number -> number
product numbers =
    foldl (*) 1 numbers


{-| Find the maximum element in a non-empty list.

    maximum [1,4,2] == Just 4
    maximum []      == Nothing

-}
maximum : List comparable -> Maybe comparable
maximum list =
    case list of
        x :: xs ->
            Just (foldl max x xs)

        _ ->
            Nothing


{-| Find the minimum element in a non-empty list.

    minimum [3,2,1] == Just 1
    minimum []      == Nothing

-}
minimum : List comparable -> Maybe comparable
minimum list =
    case list of
        x :: xs ->
            Just (foldl min x xs)

        _ ->
            Nothing


{-| Partition a list based on a predicate. The first list contains all values
that satisfy the predicate, and the second list contains all the value that do
not.

    partition (\x -> x < 3)      [0,1,2,3,4,5] == ([0,1,2], [3,4,5])
    partition (\a -> a % 2 == 0) [0,1,2,3,4,5] == ([0,2,4], [1,3,5])

-}
partition : (a -> Bool) -> List a -> ( List a, List a )
partition pred list =
    foldr (partitionStep pred) ( [], [] ) list


partitionStep : (a -> Bool) -> a -> ( List a, List a ) -> ( List a, List a )
partitionStep pred x ( trues, falses ) =
    if pred x then
        ( x :: trues, falses )
    else
        ( trues, x :: falses )


{-| Combine two lists, combining them with the given function.
If one list is longer, the extra elements are dropped.

    map2 (+) [1,2,3] [1,2,3,4] == [2,4,6]

    map2 (,) [1,2,3] ['a','b'] == [ (1,'a'), (2,'b') ]

-}
map2 : (a -> b -> result) -> List a -> List b -> List result
map2 f a b =
    zip_ a b
        |> map (uncurry f)


zip_ : List a -> List b -> List ( a, b )
zip_ =
    ffi "Enum" "zip"



-- {-|-}
-- map3 : (a -> b -> c -> result) -> List a -> List b -> List c -> List result
-- map3 =
--   Native.List.map3
-- {-|-}
-- map4 : (a -> b -> c -> d -> result) -> List a -> List b -> List c -> List d -> List result
-- map4 =
--   Native.List.map4
-- {-|-}
-- map5 : (a -> b -> c -> d -> e -> result) -> List a -> List b -> List c -> List d -> List e -> List result
-- map5 =
--   Native.List.map5


{-| Decompose a list of tuples into a tuple of lists.

    unzip (repeat 3 (0, True)) == ([0,0,0], [True,True,True])

-}
unzip : List ( a, b ) -> ( List a, List b )
unzip pairs =
    foldr unzipStep ( [], [] ) pairs


unzipStep : ( a, b ) -> ( List a, List b ) -> ( List a, List b )
unzipStep ( x, y ) ( xs, ys ) =
    ( x :: xs, y :: ys )


{-| Places the given value between all members of the given list.

    intersperse "on" ["turtles","turtles","turtles"] == ["turtles","on","turtles","on","turtles"]

-}
intersperse : a -> List a -> List a
intersperse sep xs =
    case xs of
        [] ->
            []

        hd :: tl ->
            let
                step x rest =
                    sep :: x :: rest

                spersed =
                    foldr step [] tl
            in
                hd :: spersed


{-| Take the first *n* members of a list.

    take 2 [1,2,3,4] == [1,2]

-}
take : Int -> List a -> List a
take n list =
    takeFast 0 n list


takeFast : Int -> Int -> List a -> List a
takeFast ctr n list =
    if n <= 0 then
        []
    else
        case ( n, list ) of
            ( _, [] ) ->
                list

            ( 1, x :: _ ) ->
                [ x ]

            ( 2, x :: y :: _ ) ->
                [ x, y ]

            ( 3, x :: y :: z :: _ ) ->
                [ x, y, z ]

            ( _, x :: y :: z :: w :: tl ) ->
                if ctr > 1000 then
                    x :: y :: z :: w :: takeTailRec (n - 4) tl
                else
                    x :: y :: z :: w :: takeFast (ctr + 1) (n - 4) tl

            _ ->
                list


takeTailRec : Int -> List a -> List a
takeTailRec n list =
    reverse (takeReverse n list [])


takeReverse : Int -> List a -> List a -> List a
takeReverse n list taken =
    if n <= 0 then
        taken
    else
        case list of
            [] ->
                taken

            x :: xs ->
                takeReverse (n - 1) xs (x :: taken)


{-| Drop the first *n* members of a list.

    drop 2 [1,2,3,4] == [3,4]

-}
drop : Int -> List a -> List a
drop n list =
    if n <= 0 then
        list
    else
        case list of
            [] ->
                list

            x :: xs ->
                drop (n - 1) xs


{-| Create a list with only one element:

    singleton 1234 == [1234]
    singleton "hi" == ["hi"]

-}
singleton : a -> List a
singleton value =
    [ value ]


{-| Create a list with *n* copies of a value:

    repeat 3 0 == [0, 0, 0]

-}
repeat : Int -> a -> List a
repeat n value =
    repeatHelp [] n value


repeatHelp : List a -> Int -> a -> List a
repeatHelp result n value =
    if n <= 0 then
        result
    else
        repeatHelp (value :: result) (n - 1) value


{-| Create a list of numbers, every element increasing by one.
You give the lowest and highest number that should be in the list.

    range 3 6 == [3, 4, 5, 6]
    range 3 3 == [3]
    range 6 3 == []

-}
range : Int -> Int -> List Int
range lo hi =
    rangeHelp lo hi []


rangeHelp : Int -> Int -> List Int -> List Int
rangeHelp lo hi list =
    if lo <= hi then
        rangeHelp lo (hi - 1) (hi :: list)
    else
        list


{-| Sort values from lowest to highest

    sort [3,1,5] == [1,3,5]

-}
sort : List comparable -> List comparable
sort xs =
    sortBy identity xs


{-| Sort values by a derived property. To be replaced

    sortBy (\(i, a) -> i)  [(1, "mouse"),(0, "cat")] == [(0, "cat"), (1, "mouse")]

-}
sortBy : (a -> comparable) -> List a -> List a
sortBy f list =
    sortWith (\a b -> compare (f a) (f b)) list


{-| Sort values with a custom comparison function.

    sortWith (flip compare) [1,2,3,4,5] == [5,4,3,2,1]

This is also the most general sort function, allowing you
to define any other: `sort == sortWith compare`
f

-}
sortWith : (a -> a -> Order) -> List a -> List a
sortWith f list =
    let
        exf a b =
            (f a b)
                |> (\a ->
                        case a of
                            GT ->
                                False

                            EQ ->
                                False

                            LT ->
                                True
                   )
    in
        sort_ list exf


sort_ : List a -> (a -> b -> Bool) -> List a
sort_ =
    ffi "Enum" "sort"
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XMaybe.elm
module Elmchemy.XMaybe exposing
    ( Maybe(Just, Nothing)
    , andThen
    , map
    , map2
    , map3
    , map4
    , map5
    , withDefault
    )

{-| This library fills a bunch of important niches in Elm. A `Maybe` can help
you with optional arguments, error handling, and records with optional fields.


# Definition

@docs Maybe


# Common Helpers

@docs withDefault, map, map2, map3, map4, map5


# Chaining Maybes

@docs andThen

-}


{-| Represent values that may or may not exist. It can be useful if you have a
record field that is only filled in sometimes. Or if a function takes a value
sometimes, but does not absolutely need it.
-}
type Maybe a
    = Just a
    | Nothing


{-| Provide a default value, turning an optional value into a normal
value. This comes in handy when paired with functions like
[`Dict.get`](Dict#get) which gives back a `Maybe`.

    withDefault 100 (Just 42)   == 42
    withDefault 100 Nothing     == 100

-}
withDefault : a -> Maybe a -> a
withDefault default maybe =
    case maybe of
        Nothing ->
            default

        Just value ->
            value



{- flag
   nospec:+map
   nospec:+map2
   nospec:+map3
   nospec:+map4
   nospec:+map5
-}


{-| Transform a `Maybe` value with a given function:

    map ((+) 2) (Just 9) == Just 11
    map ((+) 2) Nothing == Nothing

-}
map : (a -> b) -> Maybe a -> Maybe b
map f maybe =
    case maybe of
        Nothing ->
            Nothing

        Just value ->
            Just (f value)


{-| Apply a function if all the arguments are `Just` a value.

    map2 (+) (Just 3) (Just 4) == Just 7
    map2 (+) (Just 3) Nothing == Nothing
    map2 (+) Nothing (Just 4) == Nothing

-}
map2 : (a -> b -> value) -> Maybe a -> Maybe b -> Maybe value
map2 func ma mb =
    case ( ma, mb ) of
        ( Just a, Just b ) ->
            Just (func a b)

        _ ->
            Nothing


{-| -}
map3 : (a -> b -> c -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe value
map3 func ma mb mc =
    case ( ma, mb, mc ) of
        ( Just a, Just b, Just c ) ->
            Just (func a b c)

        _ ->
            Nothing


{-| -}
map4 : (a -> b -> c -> d -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe value
map4 func ma mb mc md =
    case ( ma, mb, mc, md ) of
        ( Just a, Just b, Just c, Just d ) ->
            Just (func a b c d)

        _ ->
            Nothing


{-| -}
map5 : (a -> b -> c -> d -> e -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe e -> Maybe value
map5 func ma mb mc md me =
    case ( ma, mb, mc, md, me ) of
        ( Just a, Just b, Just c, Just d, Just e ) ->
            Just (func a b c d e)

        _ ->
            Nothing


{-| Chain together many computations that may fail. It is helpful to see its
definition:

This means we only continue with the callback if things are going well. For
example, say you need to use (`head : List Int -> Maybe Int`) to get the
first month from a `List` and then make sure it is between 1 and 12:

If `head` fails and results in `Nothing` (because the `List` was `empty`),
this entire chain of operations will short-circuit and result in `Nothing`.
If `toValidMonth` results in `Nothing`, again the chain of computations
will result in `Nothing`.

-}



{- flag nospec:+andThen -}


andThen : (a -> Maybe b) -> Maybe a -> Maybe b
andThen callback maybeValue =
    case maybeValue of
        Just value ->
            callback value

        Nothing ->
            Nothing
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XResult.elm
module Elmchemy.XResult
    exposing
        ( Result(..)
        , withDefault
        , map
        , map2
        , map3
        , map4
        , map5
        , andThen
        , toMaybe
        , fromMaybe
        , mapError
        )

{-| A `Result` is the result of a computation that may fail. This is a great
way to manage errors in Elm.


# Type and Constructors

@docs Result


# Mapping

@docs map, map2, map3, map4, map5


# Chaining

@docs andThen


# Handling Errors

@docs withDefault, toMaybe, fromMaybe, mapError

-}

import Elmchemy exposing (..)


{-| A `Result` is either `Ok` meaning the computation succeeded, or it is an
`Err` meaning that there was some failure.
-}
type Result error value
    = Ok value
    | Err error


{-| If the result is `Ok` return the value, but if the result is an `Err` then
return a given default value. The following examples try to parse integers.

    XResult.withDefault 0 (XString.toInt "123") == 123
    XResult.withDefault 0 (XString.toInt "abc") == 0

-}
withDefault : a -> Result x a -> a
withDefault def result =
    case result of
        Ok a ->
            a

        Err _ ->
            def


{-| Apply a function to a result. If the result is `Ok`, it will be converted.
If the result is an `Err`, the same error value will propagate through.

    map sqrt (Ok 4.0)          == Ok 2.0
    map sqrt (Err "bad input") == Err "bad input"

-}
map : (a -> value) -> Result x a -> Result x value
map func ra =
    case ra of
        Ok a ->
            Ok (func a)

        Err e ->
            Err e


{-| Apply a function to two results, if both results are `Ok`. If not,
the first argument which is an `Err` will propagate through.

    map2 (+) (XString.toInt "1") (XString.toInt "2") == Ok 3
    map2 (+) (XString.toInt "1") (XString.toInt "y") == Err "could not convert string 'y' to an Int"
    map2 (+) (XString.toInt "x") (XString.toInt "y") == Err "could not convert string 'x' to an Int"

-}
map2 : (a -> b -> value) -> Result x a -> Result x b -> Result x value
map2 func ra rb =
    case ( ra, rb ) of
        ( Ok a, Ok b ) ->
            Ok (func a b)

        ( Err x, _ ) ->
            Err x

        ( _, Err x ) ->
            Err x


{-| -}
map3 : (a -> b -> c -> value) -> Result x a -> Result x b -> Result x c -> Result x value
map3 func ra rb rc =
    case ( ra, rb, rc ) of
        ( Ok a, Ok b, Ok c ) ->
            Ok (func a b c)

        ( Err x, _, _ ) ->
            Err x

        ( _, Err x, _ ) ->
            Err x

        ( _, _, Err x ) ->
            Err x


{-| -}
map4 : (a -> b -> c -> d -> value) -> Result x a -> Result x b -> Result x c -> Result x d -> Result x value
map4 func ra rb rc rd =
    case ( ra, rb, rc, rd ) of
        ( Ok a, Ok b, Ok c, Ok d ) ->
            Ok (func a b c d)

        ( Err x, _, _, _ ) ->
            Err x

        ( _, Err x, _, _ ) ->
            Err x

        ( _, _, Err x, _ ) ->
            Err x

        ( _, _, _, Err x ) ->
            Err x


{-| -}
map5 : (a -> b -> c -> d -> e -> value) -> Result x a -> Result x b -> Result x c -> Result x d -> Result x e -> Result x value
map5 func ra rb rc rd re =
    case ( ra, rb, rc, rd, re ) of
        ( Ok a, Ok b, Ok c, Ok d, Ok e ) ->
            Ok (func a b c d e)

        ( Err x, _, _, _, _ ) ->
            Err x

        ( _, Err x, _, _, _ ) ->
            Err x

        ( _, _, Err x, _, _ ) ->
            Err x

        ( _, _, _, Err x, _ ) ->
            Err x

        ( _, _, _, _, Err x ) ->
            Err x


{-| Chain together a sequence of computations that may fail. It is helpful
to see its definition:

This means we only continue with the callback if things are going well. For
example, say you need to use (`toInt : String -> Result String Int`) to parse
a month and make sure it is between 1 and 12:

This allows us to come out of a chain of operations with quite a specific error
message. It is often best to create a custom type that explicitly represents
the exact ways your computation may fail. This way it is easy to handle in your
code.

-}
andThen : (a -> Result x b) -> Result x a -> Result x b
andThen callback result =
    case result of
        Ok value ->
            callback value

        Err msg ->
            Err msg


{-| Transform an `Err` value. For example, say the errors we get have too much
information:

    mapError XTuple.first (Ok (123, 1)) == Ok (123, 1)
    mapError XTuple.second (Err ("nothing", "important")) == Err "important"

-}
mapError : (x -> y) -> Result x a -> Result y a
mapError f result =
    case result of
        Ok v ->
            Ok v

        Err e ->
            Err (f e)


{-| Convert to a simpler `Maybe` if the actual error message is not needed or
you need to interact with some code that primarily uses maybes.
-}
toMaybe : Result x a -> Maybe a
toMaybe result =
    case result of
        Ok v ->
            Just v

        Err _ ->
            Nothing


{-| Convert from a simple `Maybe` to interact with some code that primarily
uses `Results`.
-}
fromMaybe : x -> Maybe a -> Result x a
fromMaybe err maybe =
    case maybe of
        Just v ->
            Ok v

        Nothing ->
            Err err
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XString.elm
module Elmchemy.XString
    exposing
        ( isEmpty
        , length
        , reverse
        , repeat
        , cons
        , uncons
        , fromChar
        , append
        , concat
        , split
        , join
        , words
        , lines
        , slice
        , left
        , right
        , dropLeft
        , dropRight
        , contains
        , startsWith
        , endsWith
        , indexes
        , indices
        , toInt
        , toFloat
        , toList
        , fromList
        , toUpper
        , toLower
        , pad
        , padLeft
        , padRight
        , trim
        , trimLeft
        , trimRight
        , map
        , filter
        , foldl
        , foldr
        , any
        , all
        )

{-| A built-in representation for efficient string manipulation. String literals
are enclosed in `"double quotes"`. Strings are *not* lists of characters.


# Basics

@docs isEmpty, length, reverse, repeat


# Building and Splitting

@docs cons, uncons, fromChar, append, concat, split, join, words, lines


# Get Substrings

@docs slice, left, right, dropLeft, dropRight


# Check for Substrings

@docs contains, startsWith, endsWith, indexes, indices


# Conversions

@docs toInt, toFloat, toList, fromList


# Formatting

Cosmetic operations such as padding with extra characters or trimming whitespace.

@docs toUpper, toLower, pad, padLeft, padRight, trim, trimLeft, trimRight


# Higher-Order Functions

@docs map, filter, foldl, foldr, any, all

-}

import Elmchemy exposing (..)
import Elmchemy.XResult as XResult
import Elmchemy.XList as XList
import Elmchemy.XTuple as XTuple


{- ex
   import Kernel, except: [
     {:length, 1},
     {:'++', 2},
     {:to_charlist, 1}

   ]
   import Elmchemy.XBasics, except: [
     {:to_float, 1},
    ]
-}


{-| Determine if a string is empty.

    isEmpty "" == True
    isEmpty "the world" == False

-}
isEmpty : String -> Bool
isEmpty str =
    length str == 0


{-| Add a character to the beginning of a string.

    XString.cons 'T' "he truth is out there" == "The truth is out there"

-}
cons : Char -> String -> String
cons c str =
    fromChar c ++ str


{-| Create a string from a given character.

    fromChar 'a' == "a"

-}
fromChar : Char -> String
fromChar =
    ffi ":binary" "list_to_bin"


{-| Split a non-empty string into its head and tail. This lets you
pattern match on strings exactly as you would with lists.

    uncons "abc" == Just ('a',"bc")
    uncons ""    == Nothing

-}
uncons : String -> Maybe ( Char, String )
uncons str =
    let
        ( first, rest ) =
            (splitAt_ str 1)

        realFirst =
            first |> toList
    in
        case realFirst of
            [] ->
                Nothing

            [ r ] ->
                Just ( r, rest )

            _ ->
                Nothing


splitAt_ : String -> Int -> ( String, String )
splitAt_ =
    ffi "String" "split_at"


{-| Append two strings. You can also use [the `(++)` operator](Basics#++)
to do this.

    append "butter" "fly" == "butterfly"

-}
append : String -> String -> String
append a b =
    a ++ b


{-| Concatenate many strings into one.

    concat ["never","the","less"] == "nevertheless"

-}
concat : List String -> String
concat list =
    XList.foldr (++) "" list


{-| Get the length of a string.

    length "innumerable" == 11
    length "" == 0

-}
length : String -> Int
length =
    ffi "String" "length"



{- flag nospec:+map -}


{-| Transform every character in a string

    map (\c -> if c == '/' then '.' else c) "a/b/c" == "a.b.c"

-}
map : (Char -> Char) -> String -> String
map f str =
    str
        |> toList
        |> (\str -> List.map f str)
        |> List.map fromChar
        |> join ""



{- flag nospec:+filter -}


{-| Keep only the characters that satisfy the predicate.

    filter ((==) '2') "R2-D2" == "22"

-}
filter : (Char -> Bool) -> String -> String
filter f str =
    str
        |> toList
        |> (\str -> List.filter f str)
        |> List.map fromChar
        |> join ""


{-| Reverse a string.

    reverse "stressed" == "desserts"

-}
reverse : String -> String
reverse =
    ffi "String" "reverse"



{- flag nospec:+foldl -}


{-| Reduce a string from the left.

    foldl XString.cons "" "time" == "emit"

-}
foldl : (Char -> b -> b) -> b -> String -> b
foldl f acc str =
    str
        |> toList
        |> XList.foldl f acc



{- flag nospec:+foldr -}


{-| Reduce a string from the right.

    foldr XString.cons "" "time" == "time"

-}
foldr : (Char -> b -> b) -> b -> String -> b
foldr f acc str =
    str
        |> toList
        |> XList.foldr f acc


{-| Split a string using a given separator.

    split "," "cat,dog,cow"        == ["cat","dog","cow"]
    split "/" "home/evan/Desktop/" == ["home","evan","Desktop", ""]

Use [`Regex.split`](Regex#split) if you need something more flexible.

-}
split : String -> String -> List String
split pattern str =
    split_ str [ pattern ] []


type SplitOption
    = Trim Bool


split_ : String -> List String -> List SplitOption -> List String
split_ =
    ffi "String" "split"


{-| Put many strings together with a given separator.

    join "a" ["H","w","ii","n"]        == "Hawaiian"
    join " " ["cat","dog","cow"]       == "cat dog cow"
    join "/" ["home","evan","Desktop"] == "home/evan/Desktop"

-}
join : String -> List String -> String
join str list =
    join_ list str


join_ : List String -> String -> String
join_ =
    ffi "Enum" "join"


{-| Repeat a string *n* times.

    repeat 3 "ha" == "hahaha"

-}
repeat : Int -> String -> String
repeat n str =
    repeat_ str n


repeat_ : String -> Int -> String
repeat_ =
    ffi "String" "duplicate"


{-| Take a substring given a start and end index. Negative indexes
are taken starting from the *end* of the list.

    slice  7  9 "snakes on a plane!" == "on"
    slice  0  6 "snakes on a plane!" == "snakes"
    slice  0 -7 "snakes on a plane!" == "snakes on a"
    slice -6 -1 "snakes on a plane!" == "plane"

-}



-- slice 7 9 = slice 7 (9 - 7)
--                     7  2
-- slice 0 6 = slice 0 (6 - 0)
--                     0 6
-- slice 0 -7 = slice 0 (18 - 7 - 0)
--                      0  11
-- slice -6 -1 = slice ((18 - 6)) (18 - 1 - 12)
--                          12       5


slice : Int -> Int -> String -> String
slice from to str =
    let
        l =
            length str

        mirror a =
            if a < 0 then
                l + a
            else
                a

        start =
            mirror from

        len =
            (mirror to) - start
    in
        slice_ str start len


slice_ : String -> Int -> Int -> String
slice_ =
    ffi "String" "slice"


{-| Take *n* characters from the left side of a string.

    left 2 "Mulder" == "Mu"

-}
left : Int -> String -> String
left n str =
    slice 0 n str


{-| Take *n* characters from the right side of a string.

    right 2 "Scully" == "ly"

-}
right : Int -> String -> String
right n str =
    slice (negate n) (length str) str


{-| Drop *n* characters from the left side of a string.

    dropLeft 2 "The Lone Gunmen" == "e Lone Gunmen"

-}
dropLeft : Int -> String -> String
dropLeft n str =
    slice n (length str) str


{-| Drop *n* characters from the right side of a string.

    dropRight 2 "Cigarette Smoking Man" == "Cigarette Smoking M"

-}
dropRight : Int -> String -> String
dropRight n str =
    slice 0 (negate n) str


{-| Pad a string on both sides until it has a given length.

    pad 5 ' ' "1"   == "  1  "
    pad 5 ' ' "11"  == "  11 "
    pad 5 ' ' "121" == " 121 "

-}
pad : Int -> Char -> String -> String
pad n c str =
    let
        right =
            (length str + n) // 2

        left =
            n
    in
        str
            |> padRight right c
            |> padLeft left c


{-| Pad a string on the left until it has a given length.

    padLeft 5 '.' "1"   == "....1"
    padLeft 5 '.' "11"  == "...11"
    padLeft 5 '.' "121" == "..121"

-}
padLeft : Int -> Char -> String -> String
padLeft n c str =
    padLeading str n (fromChar c)


padLeading : String -> Int -> String -> String
padLeading =
    ffi "String" "pad_leading"


{-| Pad a string on the right until it has a given length.

    padRight 5 '.' "1"   == "1...."
    padRight 5 '.' "11"  == "11..."
    padRight 5 '.' "121" == "121.."

-}
padRight : Int -> Char -> String -> String
padRight n c str =
    padTrailing str n (fromChar c)


padTrailing : String -> Int -> String -> String
padTrailing =
    ffi "String" "pad_trailing"


{-| Get rid of whitespace on both sides of a string.

    trim "  hats  \n" == "hats"

-}
trim : String -> String
trim =
    ffi "String" "trim"


{-| Get rid of whitespace on the left of a string.

    trimLeft "  hats  \n" == "hats  \n"

-}
trimLeft : String -> String
trimLeft =
    ffi "String" "trim_leading"


{-| Get rid of whitespace on the right of a string.

    trimRight "  hats  \n" == "  hats"

-}
trimRight : String -> String
trimRight =
    ffi "String" "trim_trailing"


{-| Break a string into words, splitting on chunks of whitespace.

    words "How are \t you? \n Good?" == ["How","are","you?","Good?"]

-}
words : String -> List String
words s =
    ffi "String" "split"


{-| Break a string into lines, splitting on newlines.

    lines "How are you?\nGood?" == ["How are you?", "Good?"]

-}
lines : String -> List String
lines str =
    split "\n" str


{-| Convert a string to all upper case. Useful for case-insensitive comparisons
and VIRTUAL YELLING.

    toUpper "skinner" == "SKINNER"

-}
toUpper : String -> String
toUpper =
    ffi "String" "upcase"


{-| Convert a string to all lower case. Useful for case-insensitive comparisons.

    toLower "X-FILES" == "x-files"

-}
toLower : String -> String
toLower =
    ffi "String" "downcase"



{- flag nospec:+any -}


{-| Determine whether *any* characters satisfy a predicate.

    any XChar.isDigit "90210" == True
    any XChar.isDigit "R2-D2" == True
    any XChar.isDigit "heart" == False

-}
any : (Char -> Bool) -> String -> Bool
any f str =
    List.any f (toList str)



{- flag nospec:+all -}


{-| Determine whether *all* characters satisfy a predicate.

    all XChar.isDigit "90210" == True
    all XChar.isDigit "R2-D2" == False
    all XChar.isDigit "heart" == False

-}
all : (Char -> Bool) -> String -> Bool
all f str =
    List.all f (toList str)


{-| See if the second string contains the first one.

    contains "the" "theory" == True
    contains "hat" "theory" == False
    contains "THE" "theory" == False

Use [`Regex.contains`](Regex#contains) if you need something more flexible.

-}
contains : String -> String -> Bool
contains pattern str =
    contains_ str pattern


contains_ : String -> String -> Bool
contains_ =
    ffi "String" " contains?"


{-| See if the second string starts with the first one.

    startsWith "the" "theory" == True
    startsWith "ory" "theory" == False

-}
startsWith : String -> String -> Bool
startsWith prefix str =
    startsWith_ str prefix


startsWith_ : String -> String -> Bool
startsWith_ prefix str =
    ffi "String" "starts_with?"


{-| See if the second string ends with the first one.

    endsWith "the" "theory" == False
    endsWith "ory" "theory" == True

-}
endsWith : String -> String -> Bool
endsWith suffix str =
    endsWith_ str suffix


endsWith_ : String -> String -> Bool
endsWith_ =
    ffi "String" "ends_with?"


{-| Get all of the indexes for a substring in another string.

    indexes "i" "Mississippi"   == [1,4,7,10]
    indexes "ss" "Mississippi"  == [2,5]
    indexes "needle" "haystack" == []

-}
indexes : String -> String -> List Int
indexes pattern str =
    matches_ str pattern
        |> List.map XTuple.first


matches_ : String -> a -> List ( Int, String )
matches_ =
    ffi ":binary" "matches"


{-| Alias for `indexes`.
-}
indices : String -> String -> List Int
indices pattern str =
    indexes pattern str


{-| Try to convert a string into an int, failing on improperly formatted strings.

    XString.toInt "123" == Ok 123
    XString.toInt "-42" == Ok -42
    XString.toInt "3.1" == Err "could not convert string '3.1' to an Int"
    XString.toInt "31a" == Err "could not convert string '31a' to an Int"

If you are extracting a number from some raw user input, you will typically
want to use [`Result.withDefault`](Result#withDefault) to handle bad data:

    XResult.withDefault 0 (XString.toInt "42") == 42
    XResult.withDefault 0 (XString.toInt "ab") == 0

-}
toInt : String -> Result String Int
toInt str =
    case toInt_ str of
        Err "argument error" ->
            Err ("could not convert string '" ++ str ++ "' to an Int")

        e ->
            e


toInt_ : String -> Result String Int
toInt_ =
    tryFfi "String" "to_integer"


{-| Try to convert a string into a float, failing on improperly formatted strings.

    XString.toFloat "123" == Ok 123.0
    XString.toFloat "-42" == Ok -42.0
    XString.toFloat "3.1" == Ok 3.1
    XString.toFloat "31a" == Err "could not convert string '31a' to a Float"

If you are extracting a number from some raw user input, you will typically
want to use [`Result.withDefault`](Result#withDefault) to handle bad data:

    XResult.withDefault 0 (XString.toFloat "42.5") == 42.5
    XResult.withDefault 0 (XString.toFloat "cats") == 0

-}
toFloat : String -> Result String Float
toFloat str =
    let
        real =
            if contains "." str then
                str
            else
                str ++ ".0"
    in
        case toFloat_ real of
            Err "argument error" ->
                Err ("could not convert string '" ++ str ++ "' to a Float")

            e ->
                e


toFloat_ : String -> Result String Float
toFloat_ =
    tryFfi "String" "to_float"


{-| Convert a string to a list of characters.

    toList "abc" == ['a','b','c']

-}
toList : String -> List Char
toList str =
    let
        charlist =
            toCharlist_ str
    in
        map_ charlist List.singleton



{- It's ugly but it's the only way since there's no
   Chars in Elixir
-}
{- flag noverify:+toCharlist -}


toCharlist_ : String -> List Int
toCharlist_ =
    ffi "String" "to_charlist"



{- flag noverify:+map_ -}


map_ : List Int -> (Int -> List Int) -> List Char
map_ =
    ffi "Enum" "map"


{-| Convert a list of characters into a String. Can be useful if you
want to create a string primarily by consing, perhaps for decoding
something.

    fromList ['a','b','c'] == "abc"

-}
fromList : List Char -> String
fromList list =
    joinChars_ list ""


joinChars_ : List Char -> String -> String
joinChars_ =
    ffi "Enum" "join"
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XTuple.elm
module Elmchemy.XTuple exposing
    ( first
    , second
    , mapFirst
    , mapSecond
    )
{-|
Module for tuple manipulation

@docs first, second, mapFirst, mapSecond
-}

{-| Extract the first value from a tuple.

    first (3, 4) == 3
    first ("john", "doe") == "john"
 -}
first : ( a, b ) -> a
first ( fst, _ ) =
    fst


{-| Extract the second value from a tuple.

    second (3, 4) == 4
    second ("john", "doe") == "doe"
 -}
second : ( a, b ) -> b
second ( _, snd ) =
    snd



{-| Transform the first value in a tuple.

    mapFirst String.reverse ("stressed", 16) == ("desserts", 16)
    mapFirst String.length  ("stressed", 16) == (8, 16)
 -}
mapFirst : (a -> a1) -> ( a, b ) -> ( a1, b )
mapFirst f ( fst, snd ) =
    ( f fst, snd )


{-| Transform the second value in a tuple.

    mapSecond sqrt          ("stressed", 16) == ("stressed", 4.0)
    mapSecond (\x -> x + 1) ("stressed", 16) == ("stressed", 17)
 -}
mapSecond : (b -> b1) -> ( a, b ) -> ( a, b1 )
mapSecond f ( fst, snd ) =
    ( fst, f snd )
