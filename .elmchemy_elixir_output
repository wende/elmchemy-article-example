>>>>elm/Hello.elm
# Compiled using Elmchemy v0.3.7
defmodule Hello do
  use Elmchemy

  @doc """
  Prints "world!"
  
  
      iex> import Hello
      iex> hello
      "world!"
  
 
  """
  @spec hello() :: String.t
  def hello() do
    "world!"
  end

end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XBasics.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XBasics do
  use Elmchemy

  @doc """
  Tons of useful functions that get imported by default.
  @docs compare, xor, sqrt, clamp, compare , xor , negate , sqrt , logBase , e , pi , cos , sin , tan , acos , asin , atan , atan2 , round , floor , ceiling , truncate , toFloat , toString , (++) , identity , always, flip, tuple2, tuple3, tuple4, tuple5
  
  @docs Order
  
  
 
  """
  import Elmchemy
  @doc """
  Represents the relative ordering of two things.
  The relations are less than, equal to, and greater than.
  
 
  """
  @type order :: :lt | :eq | :gt
  #  Operators


  import Kernel, except: [
  {:'++', 2},
  {:round, 1},
  {:to_string, 1}

  ]

  curry ==/2
  curry !=/2
  curry </2
  curry >/2
  curry <=/2
  curry >=/2
  curry max/2
  curry min/2

  curry &&/2
  curry ||/2

  curry +/2
  curry -/2
  curry */2
  curry //2
  curry div/2
  curry rem/2
  curry abs/1
  # Inlined from not
  curry !/1


  @doc """
  Basic compare function
  
  
  ### Example
  
  
      iex> import Elmchemy.XBasics
      iex> compare.(1).(2)
      :lt
  
  
 
  """
  @spec compare() :: (any -> (any -> order))
  @spec compare(any, any) :: order
  curry compare/2
  def compare(a, b) do
    cond do
      a > b -> :gt
      a < b -> :lt
      true -> :eq
    end
  end


  # >> is replaced with >>> by the compiler
  def l >>> r do
  fn x -> r.(l.(x)) end
  end


  #  not/1 is inlined by the compiler
  @doc """
  The exclusive-or operator. `True` if exactly one input is `True`.
  
 
  """
  @spec xor() :: (boolean -> (boolean -> boolean))
  @spec xor(boolean, boolean) :: boolean
  curry xor/2
  def xor(a, b) do
    a && (&!/0).().(b) || (&!/0).().(a) && b
  end

  @doc """
  Negate a number.
  
  
      iex> import Elmchemy.XBasics
      iex> negate.(42)
      -42
  
      iex> import Elmchemy.XBasics
      iex> negate.(-42)
      42
  
      iex> import Elmchemy.XBasics
      iex> negate.(0)
      0
  
  
 
  """
  @spec negate() :: (number -> number)
  @spec negate(number) :: number
  curry negate/1
  verify as: Kernel.-/1
  def negate(a1), do: Kernel.-(a1)
  @doc """
  Take the square root of a number.
  
 
  """
  @spec sqrt() :: (number -> float)
  @spec sqrt(number) :: float
  curry sqrt/1
  verify as: :math.sqrt/1
  def sqrt(a1), do: :math.sqrt(a1)
  @doc """
  Clamps a number within a given range. With the expression
  `clamp 100 200 x` the results are as follows:
  100 if x < 100
  x if 100 <= x < 200
  200 if 200 <= x
  
 
  """
  @spec clamp() :: (any -> (any -> (any -> any)))
  @spec clamp(any, any, any) :: any
  curry clamp/3
  def clamp(x, bottom, top) do
    x
    |> (min.(bottom)).()
    |> (max.(top)).()
  end

  @doc """
 
 
  """
  @spec log_base() :: (float -> (float -> float))
  @spec log_base(float, float) :: float
  curry log_base/2
  def log_base(a, b) do
    not_implemented
  end

  @doc """
 
 
  """
  @spec e() :: float
  def e() do
    2.71828
  end

  @doc """
 
 
  """
  @spec pi() :: float
  verify as: :math.pi/0
  def pi(), do: :math.pi()
  @doc """
 
 
  """
  @spec cos() :: (float -> float)
  @spec cos(float) :: float
  curry cos/1
  verify as: :math.cos/1
  def cos(a1), do: :math.cos(a1)
  @doc """
 
 
  """
  @spec sin() :: (float -> float)
  @spec sin(float) :: float
  curry sin/1
  verify as: :math.sin/1
  def sin(a1), do: :math.sin(a1)
  @doc """
 
 
  """
  @spec tan() :: (float -> float)
  @spec tan(float) :: float
  curry tan/1
  verify as: :math.tan/1
  def tan(a1), do: :math.tan(a1)
  @doc """
 
 
  """
  @spec acos() :: (float -> float)
  @spec acos(float) :: float
  curry acos/1
  verify as: :math.acos/1
  def acos(a1), do: :math.acos(a1)
  @doc """
 
 
  """
  @spec asin() :: (float -> float)
  @spec asin(float) :: float
  curry asin/1
  verify as: :math.asin/1
  def asin(a1), do: :math.asin(a1)
  @doc """
 
 
  """
  @spec atan() :: (float -> float)
  @spec atan(float) :: float
  curry atan/1
  verify as: :math.atan/1
  def atan(a1), do: :math.atan(a1)
  @doc """
 
 
  """
  @spec atan2() :: (float -> (float -> float))
  @spec atan2(float, float) :: float
  curry atan2/2
  verify as: :math.atan2/2
  def atan2(a1, a2), do: :math.atan2(a1, a2)
  @doc """
 
 
  """
  @spec round() :: (float -> integer)
  @spec round(float) :: integer
  curry round/1
  verify as: Kernel.round/1
  def round(a1), do: Kernel.round(a1)
  @doc """
 
 
  """
  @spec floor() :: (float -> integer)
  @spec floor(float) :: integer
  curry floor/1
  def floor(x) do
    not_implemented
  end

  @doc """
 
 
  """
  @spec ceiling() :: (float -> integer)
  @spec ceiling(float) :: integer
  curry ceiling/1
  def ceiling(x) do
    not_implemented
  end

  @doc """
  Truncate a number, rounding towards zero.
  
 
  """
  @spec truncate() :: (float -> integer)
  @spec truncate(float) :: integer
  curry truncate/1
  def truncate(x) do
    not_implemented
  end

  @doc """
  Convert an integer into a float.
  
 
  """
  @spec to_float() :: (integer -> float)
  @spec to_float(integer) :: float
  curry to_float/1
  def to_float(x) do
    mul_.(x).(1.0)
  end

  @spec mul_() :: (integer -> (float -> float))
  @spec mul_(integer, float) :: float
  curryp mul_/2
  verify as: Kernel.*/2
  def mul_(a1, a2), do: Kernel.*(a1, a2)
  @doc """
  Turn any kind of value into a string. When you view the resulting string
  with `Text.fromString` it should look just like the value it came from.
  
  
      iex> import Elmchemy.XBasics
      iex> to_string.(42)
      "42"
  
      iex> import Elmchemy.XBasics
      iex> to_string.([1, 2])
      "[1, 2]"
  
  
 
  """
  @spec to_string() :: (any -> String.t)
  @spec to_string(any) :: String.t
  curry to_string/1
  def to_string(a) do
    inspect_.(a).([])
  end

  @type binaries_as :: :as_binaries | :as_strings
  @type inspect_option :: {:structs, boolean} | {:binaries, binaries_as}
  @spec inspect_() :: (any -> (list(inspect_option) -> String.t))
  @spec inspect_(any, list(inspect_option)) :: String.t
  curryp inspect_/2
  verify as: Kernel.inspect/2
  def inspect_(a1, a2), do: Kernel.inspect(a1, a2)
  @doc """
  Put two appendable things together. This includes strings, lists, and text.
  
  
      iex> import Elmchemy.XBasics
      iex> "hello" ++ "world"
      "helloworld"
  
      iex> import Elmchemy.XBasics
      iex> [1, 1, 2] ++ [3, 5, 8]
      [1, 1, 2, 3, 5, 8]
  
  
 
  """
  curry ++/2
  def a ++ b do
    if is_binary_.(a) && is_binary_.(b) do add_strings_.(a).(b) else add_lists_.(a).(b) end
  end

  @spec is_binary_() :: (any -> boolean)
  @spec is_binary_(any) :: boolean
  curryp is_binary_/1
  verify as: Kernel.is_binary/1
  def is_binary_(a1), do: Kernel.is_binary(a1)
  @spec add_strings_() :: (any -> (any -> any))
  @spec add_strings_(any, any) :: any
  curryp add_strings_/2
  def add_strings_(a1, a2), do: Kernel.<>(a1, a2)
  @spec add_lists_() :: (any -> (any -> any))
  @spec add_lists_(any, any) :: any
  curryp add_lists_/2
  def add_lists_(a1, a2), do: Kernel.++(a1, a2)
  @doc """
  Given a value, returns exactly the same value. This is called
  [the identity function](http://en.wikipedia.org/wiki/Identity_function).
  
 
  """
  @spec identity() :: (any -> any)
  @spec identity(any) :: any
  curry identity/1
  def identity(a) do
    a
  end

  @doc """
  Create a function that *always* returns the same value. Useful with
  functions like `map`:
  
  
      iex> import Elmchemy.XBasics
      iex> XList.map.(always.(0)).([1, 2, 3, 4, 5])
      [0, 0, 0, 0, 0]
  
      iex> import Elmchemy.XBasics
      iex> XList.map.(fn(_) -> 0 end).([1, 2, 3, 4, 5])
      [0, 0, 0, 0, 0]
  
  
 
  """
  @spec always() :: (any -> (any -> any))
  @spec always(any, any) :: any
  curry always/2
  def always(a, b) do
    a
  end

  @doc """
  Flip the order of the first two arguments to a function.
  
 
  """
  @spec flip() :: ((any -> (any -> any)) -> (any -> (any -> any)))
  @spec flip((any -> (any -> any)), any, any) :: any
  curry flip/3
  def flip(f, a, b) do
    f.(b).(a)
  end

  #  TODO Will be fixed with #34

  @spec curried(({any, any} -> any)) :: ((any -> any) -> any)
  curry curried/1
  def curried(fun) do
  fn fst -> fn snd -> fun.({fst, snd}) end end
  end

  @spec uncurried(((any -> any) -> any)) :: ({any, any} -> any)
  curry uncurried/1
  def uncurried(fun) do
  fn {fst, snd} -> fun.(fst).(snd) end
  end


  #  We don't care for Never type
  #  Additional
  @spec not_implemented() :: any
  defp not_implemented() do
    _ = throw_.("Not implemented")
    Debug.crash.("a")
  end

  @spec throw_() :: (String.t -> no_return)
  @spec throw_(String.t) :: no_return
  curryp throw_/1
  verify as: Kernel.throw/1
  def throw_(a1), do: Kernel.throw(a1)
  @doc """
 
 
  """
  @spec tuple2() :: (any -> (any -> {any, any}))
  @spec tuple2(any, any) :: {any, any}
  curry tuple2/2
  def tuple2(a, b) do
    {a, b}
  end

  @doc """
 
 
  """
  @spec tuple3() :: (any -> (any -> (any -> {any, any, any})))
  @spec tuple3(any, any, any) :: {any, any, any}
  curry tuple3/3
  def tuple3(a, b, c) do
    {a, b, c}
  end

  @doc """
 
 
  """
  @spec tuple4() :: (any -> (any -> (any -> (any -> {any, any, any, any}))))
  @spec tuple4(any, any, any, any) :: {any, any, any, any}
  curry tuple4/4
  def tuple4(a, b, c, d) do
    {a, b, c, d}
  end

  @doc """
 
 
  """
  @spec tuple5() :: (any -> (any -> (any -> (any -> (any -> {any, any, any, any, any})))))
  @spec tuple5(any, any, any, any, any) :: {any, any, any, any, any}
  curry tuple5/5
  def tuple5(a, b, c, d, e) do
    {a, b, c, d, e}
  end

end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XChar.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XChar do
  use Elmchemy

  @doc """
  Functions for working with characters. Character literals are enclosed in
  `'a'` pair of single quotes.
  
  
  # Classification
  
  @docs isUpper, isLower, isDigit, isOctDigit, isHexDigit
  
  
  # Conversion
  
  @docs toUpper, toLower
  
  
  # Key Codes
  
  @docs KeyCode, toCode, fromCode
  
  
 
  """
  import Elmchemy
  @doc """
  True for char between first and second argument
  
  
      iex> import Elmchemy.XChar
      iex> between.('a').('z').('b')
      :true
  
      iex> import Elmchemy.XChar
      iex> between.('1').('9').('5')
      :true
  
      iex> import Elmchemy.XChar
      iex> between.('A').('Z').('g')
      :false
  
  
 
  """
  @spec is_between() :: (char_list -> (char_list -> (char_list -> boolean)))
  @spec is_between(char_list, char_list, char_list) :: boolean
  curryp is_between/3
  defp is_between(low, high, char) do
    code = to_code.(char)
    code >= to_code.(low) && code <= to_code.(high)
  end

  @doc """
  True for upper case ASCII letters.
  
  
      iex> import Elmchemy.XChar
      iex> is_upper.('D')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_upper.('A')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_upper.('x')
      :false
  
  
 
  """
  @spec is_upper() :: (char_list -> boolean)
  @spec is_upper(char_list) :: boolean
  curry is_upper/1
  def is_upper(char) do
    is_between.('A').('Z').(char)
  end

  @doc """
  True for lower case ASCII letters.
  
  
      iex> import Elmchemy.XChar
      iex> is_lower.('d')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_lower.('a')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_lower.('X')
      :false
  
  
 
  """
  @spec is_lower() :: (char_list -> boolean)
  @spec is_lower(char_list) :: boolean
  curry is_lower/1
  def is_lower(char) do
    is_between.('a').('z').(char)
  end

  @doc """
  True for ASCII digits `[0-9]`.
  
  
      iex> import Elmchemy.XChar
      iex> is_digit.('1')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_digit.('9')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_digit.('a')
      :false
  
  
 
  """
  @spec is_digit() :: (char_list -> boolean)
  @spec is_digit(char_list) :: boolean
  curry is_digit/1
  def is_digit(char) do
    is_between.('0').('9').(char)
  end

  @doc """
  True for ASCII octal digits `[0-7]`.
  
  
      iex> import Elmchemy.XChar
      iex> is_oct_digit.('7')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_oct_digit.('5')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_oct_digit.('9')
      :false
  
  
 
  """
  @spec is_oct_digit() :: (char_list -> boolean)
  @spec is_oct_digit(char_list) :: boolean
  curry is_oct_digit/1
  def is_oct_digit(char) do
    is_between.('0').('7').(char)
  end

  @doc """
  True for ASCII hexadecimal digits `[0-9a-fA-F]`.
  
  
      iex> import Elmchemy.XChar
      iex> is_hex_digit.('d')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_hex_digit.('D')
      :true
  
      iex> import Elmchemy.XChar
      iex> is_hex_digit.('x')
      :false
  
  
 
  """
  @spec is_hex_digit() :: (char_list -> boolean)
  @spec is_hex_digit(char_list) :: boolean
  curry is_hex_digit/1
  def is_hex_digit(char) do
    is_digit.(char) || is_between.('a').('f').(char) || is_between.('A').('F').(char)
  end

  @doc """
  Convert to upper case.
  
  
      iex> import Elmchemy.XChar
      iex> to_upper.('a')
      'A'
  
  
 
  """
  @spec to_upper() :: (char_list -> char_list)
  @spec to_upper(char_list) :: char_list
  curry to_upper/1
  verify as: :string.to_upper/1
  def to_upper(a1), do: :string.to_upper(a1)
  @doc """
  Convert to lower case.
  
  
      iex> import Elmchemy.XChar
      iex> to_lower.('A')
      'a'
  
  
 
  """
  @spec to_lower() :: (char_list -> char_list)
  @spec to_lower(char_list) :: char_list
  curry to_lower/1
  verify as: :string.to_lower/1
  def to_lower(a1), do: :string.to_lower(a1)
  #  {-| Convert to upper case, according to any locale-specific case mappings. -}
  #  toLocaleUpper : Char -> Char
  #  toLocaleUpper =
  #    Native.Char.toLocaleUpper
  #  {-| Convert to lower case, according to any locale-specific case mappings. -}
  #  toLocaleLower : Char -> Char
  #  toLocaleLower =
  #    Native.Char.toLocaleLower
  @doc """
  Keyboard keys can be represented as integers. These are called *key codes*.
  You can use [`toCode`](#toCode) and [`fromCode`](#fromCode) to convert between
  key codes and characters.
  
 
  """
  @doc """
  Convert to key code.
  
  
      iex> import Elmchemy.XChar
      iex> to_code.('a')
      97
  
  
 
  """
  @spec to_code() :: (char_list -> integer)
  @spec to_code(char_list) :: integer
  curry to_code/1
  def to_code(a1), do: Kernel.hd(a1)
  @doc """
  Convert from key code.
  
  
      iex> import Elmchemy.XChar
      iex> from_code.(97)
      'a'
  
  
 
  """
  @spec from_code() :: (integer -> char_list)
  @spec from_code(integer) :: char_list
  curry from_code/1
  def from_code(code) do
    insert_at_.([]).(0).(code)
  end

  @spec insert_at_() :: (list(any) -> (integer -> (any -> char_list)))
  @spec insert_at_(list(any), integer, any) :: char_list
  curryp insert_at_/3
  verify as: List.insert_at/3
  def insert_at_(a1, a2, a3), do: List.insert_at(a1, a2, a3)
end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XDebug.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XDebug do
  use Elmchemy

  @doc """
  Module with helper functions for debugging
  
  
  # Debug
  
  @docs log, crash
  
  
 
  """
  import Elmchemy
  @doc """
  Log to console in `title: object` format
  
 
  """
  @spec log() :: (String.t -> (any -> any))
  @spec log(String.t, any) :: any
  curry log/2
  def log(title, a) do
    _ = puts_.("#{title}:#{a}").([])
    a
  end

  @spec puts_() :: (any -> (list({any, any}) -> any))
  @spec puts_(any, list({any, any})) :: any
  curryp puts_/2
  verify as: IO.inspect/2
  def puts_(a1, a2), do: IO.inspect(a1, a2)
  #  We don't verify since it's a macro 
  @doc """
  Raise an exception to crash the runtime. Should be avoided at all
  costs. Helpful for crashing at not yet implelented functionality
  
 
  """
  @spec crash() :: (String.t -> any)
  @spec crash(String.t) :: any
  curry crash/1
  def crash(a1), do: Kernel.raise(a1)
end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XList.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XList do
  use Elmchemy

  @doc """
  A library for manipulating lists of values. Every value in a
  list must have the same type.
  
  
  # Basics
  
  @docs isEmpty, length, reverse, member
  
  
  # Sub-lists
  
  @docs head, tail, filter, take, drop
  
  
  # Putting Lists Together
  
  @docs singleton, repeat, range, cons, (::), append, concat, intersperse
  
  
  # Taking Lists Apart
  
  @docs partition, unzip
  
  
  # Mapping
  
  @docs map, map2
  
  If you can think of a legitimate use of `mapN` where `N` is 6 or more, please
  let us know on [the list](https://groups.google.com/forum/#!forum/elm-discuss).
  The current sentiment is that it is already quite error prone once you get to
  4 and possibly should be approached another way.
  
  
  # Special Maps
  
  @docs filterMap, concatMap, indexedMap
  
  
  # Folding
  
  @docs foldr, foldl
  
  
  # Special Folds
  
  @docs sum, product, maximum, minimum, all, any, scanl
  
  
  # Sorting
  
  @docs sort, sortBy, sortWith
  
  
 
  """
  import Elmchemy

  import Kernel, except: [{:length, 1}]
  import Elmchemy.XBasics

  @doc """
  Add an element to the front of a list. Pronounced *cons*.
  
  
      iex> import Elmchemy.XList
      iex> [1 | [2, 3]]
      [1, 2, 3]
  
      iex> import Elmchemy.XList
      iex> [1 | []]
      [1]
  
  
 
  """
  @doc """
  Add an element to the front of a list. Pronounced *cons*.
  
  
      iex> import Elmchemy.XList
      iex> cons.(1).([2, 3])
      [1, 2, 3]
  
      iex> import Elmchemy.XList
      iex> cons.(1).([])
      [1]
  
  
 
  """
  @spec cons() :: (any -> (list(any) -> list(any)))
  @spec cons(any, list(any)) :: list(any)
  curry cons/2
  def cons(a, list) do
    [a | list]
  end

  @doc """
  Extract the first element of a list.
  
  
      iex> import Elmchemy.XList
      iex> head.([1, 2, 3])
      {1}
  
      iex> import Elmchemy.XList
      iex> head.([])
      nil
  
  
 
  """
  @spec head() :: (list(any) -> any | nil)
  @spec head(list(any)) :: any | nil
  curry head/1
  def head([x | xs]) do
    {x}
  end
  def head([]) do
    nil
  end

  @doc """
  Extract the rest of the list.
  
  
      iex> import Elmchemy.XList
      iex> tail.([1, 2, 3])
      {[2, 3]}
  
      iex> import Elmchemy.XList
      iex> tail.([])
      nil
  
  
 
  """
  @spec tail() :: (list(any) -> list(any) | nil)
  @spec tail(list(any)) :: list(any) | nil
  curry tail/1
  def tail([x | xs]) do
    {xs}
  end
  def tail([]) do
    nil
  end

  @doc """
  Determine if a list is empty.
  
  
      iex> import Elmchemy.XList
      iex> is_empty.([])
      :true
  
  
 
  """
  @spec is_empty() :: (list(any) -> boolean)
  @spec is_empty(list(any)) :: boolean
  curry is_empty/1
  def is_empty([]) do
    :true
  end
  def is_empty(_) do
    :false
  end

  @doc """
  Figure out whether a list contains a value.
  
  
      iex> import Elmchemy.XList
      iex> member.(9).([1, 2, 3, 4])
      :false
  
      iex> import Elmchemy.XList
      iex> member.(4).([1, 2, 3, 4])
      :true
  
  
 
  """
  @spec member() :: (any -> (list(any) -> boolean))
  @spec member(any, list(any)) :: boolean
  curry member/2
  def member(x, xs) do
    any.(fn(a) -> a == x end).(xs)
  end

  @doc """
  Apply a function to every element of a list.
  
  
      iex> import Elmchemy.XList
      iex> map.(sqrt).([1, 4, 9])
      [1.0, 2.0, 3.0]
  
  
      iex> import Elmchemy.XList
      iex> map.((&!/0).()).([:true, :false, :true])
      [:false, :true, :false]
  
  
 
  """
  @spec map() :: ((any -> any) -> (list(any) -> list(any)))
  @spec map((any -> any), list(any)) :: list(any)
  curry map/2
  def map(f, xs) do
    foldr.(fn(x) -> fn(acc) -> [f.(x) | acc] end end).([]).(xs)
  end

  @doc """
  Same as `map` but the function is also applied to the index of each
  element (starting at zero).
  
  
      iex> import Elmchemy.XList
      iex> indexed_map.((&tuple2/0).()).(["Tom", "Sue", "Bob"])
      [{0, "Tom"}, {1, "Sue"}, {2, "Bob"}]
  
  
 
  """
  @spec indexed_map() :: ((integer -> (any -> any)) -> (list(any) -> list(any)))
  @spec indexed_map((integer -> (any -> any)), list(any)) :: list(any)
  curry indexed_map/2
  def indexed_map(f, xs) do
    map2.(f).(range.(0).(length.(xs) - 1)).(xs)
  end

  @doc """
  Reduce a list from the left.
  
  
      iex> import Elmchemy.XList
      iex> foldl.((&cons/0).()).([]).([1, 2, 3])
      [3, 2, 1]
  
  
 
  """
  @spec foldl() :: ((any -> (any -> any)) -> (any -> (list(any) -> any)))
  @spec foldl((any -> (any -> any)), any, list(any)) :: any
  curry foldl/3
  def foldl(func, acc, list) do
    case list do
      [] -> acc
      [x | xs] -> foldl.(func).(func.(x).(acc)).(xs)
    end
  end

  @doc """
  Reduce a list from the right.
  
  
      iex> import Elmchemy.XList
      iex> foldr.((&+/0).()).(0).([1, 2, 3])
      6
  
  
 
  """
  @spec foldr() :: ((any -> (any -> any)) -> (any -> (list(any) -> any)))
  @spec foldr((any -> (any -> any)), any, list(any)) :: any
  curry foldr/3
  def foldr(f, start, list) do
    foldr_.(list).(start).(f)
  end

  @spec foldr_() :: (list(any) -> (any -> ((any -> (any -> any)) -> any)))
  @spec foldr_(list(any), any, (any -> (any -> any))) :: any
  curryp foldr_/3
  verify as: List.foldr/3
  def foldr_(a1, a2, a3), do: List.foldr(a1, a2, fn (x1,x2) -> a3.(x1).(x2) end)
  @doc """
  Reduce a list from the left, building up all of the intermediate results into a list.
  
  
      iex> import Elmchemy.XList
      iex> scanl.((&+/0).()).(0).([1, 2, 3, 4])
      [0, 1, 3, 6, 10]
  
  
 
  """
  @spec scanl() :: ((any -> (any -> any)) -> (any -> (list(any) -> list(any))))
  @spec scanl((any -> (any -> any)), any, list(any)) :: list(any)
  curry scanl/3
  def scanl(f, b, xs) do
    scan1 = fn(x) -> fn(acc_acc) -> case acc_acc do
      [acc | _] -> [f.(x).(acc) | acc_acc]
      [] -> []
    end end end
    reverse.(foldl.(scan1).([b]).(xs))
  end

  @doc """
  Keep only elements that satisfy the predicate.
  
  
      iex> import Elmchemy.XList
      iex> filter.(flip.((&rem/0).()).(2) >>> (&==/0).().(0)).([1, 2, 3, 4, 5, 6])
      [2, 4, 6]
  
  
 
  """
  @spec filter() :: ((any -> boolean) -> (list(any) -> list(any)))
  @spec filter((any -> boolean), list(any)) :: list(any)
  curry filter/2
  def filter(pred, xs) do
    conditional_cons = fn(front) -> fn(back) -> if pred.(front) do [front | back] else back end end end
    foldr.(conditional_cons).([]).(xs)
  end

  @doc """
  Apply a function that may succeed to all values in the list, but only keep
  the successes.
  
  
      iex> import Elmchemy.XList
      iex> filter_map.(fn(a) -> if a >= 18 do {a} else nil end end).([3, 15, 12, 18, 24])
      [18, 24]
  
  
 
  """
  @spec filter_map() :: ((any -> any | nil) -> (list(any) -> list(any)))
  @spec filter_map((any -> any | nil), list(any)) :: list(any)
  curry filter_map/2
  def filter_map(f, xs) do
    foldr.(maybe_cons.(f)).([]).(xs)
  end

  @spec maybe_cons() :: ((any -> any | nil) -> (any -> (list(any) -> list(any))))
  @spec maybe_cons((any -> any | nil), any, list(any)) :: list(any)
  curryp maybe_cons/3
  defp maybe_cons(f, mx, xs) do
    case f.(mx) do
      {x} -> [x | xs]
      nil -> xs
    end
  end

  @doc """
  Determine the length of a list.
  
  
      iex> import Elmchemy.XList
      iex> length.([1, 2, 3])
      3
  
  
 
  """
  @spec length() :: (list(any) -> integer)
  @spec length(list(any)) :: integer
  curry length/1
  def length(xs) do
    foldl.(fn(_) -> fn(i) -> i + 1 end end).(0).(xs)
  end

  @doc """
  Reverse a list.
  
  
      iex> import Elmchemy.XList
      iex> reverse.([1, 2, 3, 4])
      [4, 3, 2, 1]
  
  
 
  """
  @spec reverse() :: (list(any) -> list(any))
  @spec reverse(list(any)) :: list(any)
  curry reverse/1
  def reverse(list) do
    foldl.((&cons/0).()).([]).(list)
  end

  @doc """
  Determine if all elements satisfy the predicate.
  
  
      iex> import Elmchemy.XList
      iex> all.(fn(a) -> rem(a, 2) == 0 end).([2, 4])
      :true
  
      iex> import Elmchemy.XList
      iex> all.(fn(a) -> rem(a, 2) == 0 end).([2, 3])
      :false
  
      iex> import Elmchemy.XList
      iex> all.(fn(a) -> rem(a, 2) == 0 end).([])
      :true
  
  
 
  """
  @spec all() :: ((any -> boolean) -> (list(any) -> boolean))
  @spec all((any -> boolean), list(any)) :: boolean
  curry all/2
  def all(is_okay, list) do
    (&!/0).().(any.(is_okay >>> (&!/0).()).(list))
  end

  @doc """
  Determine if any elements satisfy the predicate.
  
  
      iex> import Elmchemy.XList
      iex> any.(fn(a) -> rem(a, 2) == 0 end).([2, 3])
      :true
  
      iex> import Elmchemy.XList
      iex> any.(fn(a) -> rem(a, 2) == 0 end).([1, 3])
      :false
  
      iex> import Elmchemy.XList
      iex> any.(fn(a) -> rem(a, 2) == 0 end).([])
      :false
  
  
 
  """
  @spec any() :: ((any -> boolean) -> (list(any) -> boolean))
  @spec any((any -> boolean), list(any)) :: boolean
  curry any/2
  def any(is_okay, list) do
    case list do
      [] -> :false
      [x | xs] -> if is_okay.(x) do :true else any.(is_okay).(xs) end
    end
  end

  @doc """
  Put two lists together.
  
  
      iex> import Elmchemy.XList
      iex> append.([1, 1, 2]).([3, 5, 8])
      [1, 1, 2, 3, 5, 8]
  
      iex> import Elmchemy.XList
      iex> append.(['a', 'b']).(['c'])
      ['a', 'b', 'c']
  
  You can also use [the `(++)` operator](Basics#++) to append lists.
  
  
 
  """
  @spec append() :: (list(any) -> (list(any) -> list(any)))
  @spec append(list(any), list(any)) :: list(any)
  curry append/2
  def append(xs, ys) do
    case ys do
      [] -> xs
      _ -> foldr.((&cons/0).()).(ys).(xs)
    end
  end

  @doc """
  Concatenate a bunch of lists into a single list:
  
  
      iex> import Elmchemy.XList
      iex> concat.([[1, 2], [3], [4, 5]])
      [1, 2, 3, 4, 5]
  
  
 
  """
  @spec concat() :: (list(list(any)) -> list(any))
  @spec concat(list(list(any))) :: list(any)
  curry concat/1
  def concat(lists) do
    foldr.(append).([]).(lists)
  end

  @doc """
  Map a given function onto a list and flatten the resulting lists.
  
  
      iex> import Elmchemy.XList
      iex> concat_map.(range.(2)).([1]) == concat.(map.(range.(2)).([1]))
      true
  
  
 
  """
  @spec concat_map() :: ((any -> list(any)) -> (list(any) -> list(any)))
  @spec concat_map((any -> list(any)), list(any)) :: list(any)
  curry concat_map/2
  def concat_map(f, list) do
    concat.(map.(f).(list))
  end

  @doc """
  Get the sum of the list elements.
  
  
      iex> import Elmchemy.XList
      iex> sum.([1, 2, 3, 4])
      10
  
  
 
  """
  @spec sum() :: (list(number) -> number)
  @spec sum(list(number)) :: number
  curry sum/1
  def sum(numbers) do
    foldl.((&+/0).()).(0).(numbers)
  end

  @doc """
  Get the product of the list elements.
  
  
      iex> import Elmchemy.XList
      iex> product.([1, 2, 3, 4])
      24
  
  
 
  """
  @spec product() :: (list(number) -> number)
  @spec product(list(number)) :: number
  curry product/1
  def product(numbers) do
    foldl.((&*/0).()).(1).(numbers)
  end

  @doc """
  Find the maximum element in a non-empty list.
  
  
      iex> import Elmchemy.XList
      iex> maximum.([1, 4, 2])
      {4}
  
      iex> import Elmchemy.XList
      iex> maximum.([])
      nil
  
  
 
  """
  @spec maximum() :: (list(any) -> any | nil)
  @spec maximum(list(any)) :: any | nil
  curry maximum/1
  def maximum([x | xs]) do
    {foldl.(max).(x).(xs)}
  end
  def maximum(_) do
    nil
  end

  @doc """
  Find the minimum element in a non-empty list.
  
  
      iex> import Elmchemy.XList
      iex> minimum.([3, 2, 1])
      {1}
  
      iex> import Elmchemy.XList
      iex> minimum.([])
      nil
  
  
 
  """
  @spec minimum() :: (list(any) -> any | nil)
  @spec minimum(list(any)) :: any | nil
  curry minimum/1
  def minimum([x | xs]) do
    {foldl.(min).(x).(xs)}
  end
  def minimum(_) do
    nil
  end

  @doc """
  Partition a list based on a predicate. The first list contains all values
  that satisfy the predicate, and the second list contains all the value that do
  not.
  
  
      iex> import Elmchemy.XList
      iex> partition.(fn(x) -> x < 3 end).([0, 1, 2, 3, 4, 5])
      {[0, 1, 2], [3, 4, 5]}
  
      iex> import Elmchemy.XList
      iex> partition.(fn(a) -> rem(a, 2) == 0 end).([0, 1, 2, 3, 4, 5])
      {[0, 2, 4], [1, 3, 5]}
  
  
 
  """
  @spec partition() :: ((any -> boolean) -> (list(any) -> {list(any), list(any)}))
  @spec partition((any -> boolean), list(any)) :: {list(any), list(any)}
  curry partition/2
  def partition(pred, list) do
    foldr.(partition_step.(pred)).({[], []}).(list)
  end

  @spec partition_step() :: ((any -> boolean) -> (any -> ({list(any), list(any)} -> {list(any), list(any)})))
  @spec partition_step((any -> boolean), any, {list(any), list(any)}) :: {list(any), list(any)}
  curryp partition_step/3
  defp partition_step(pred, x, {trues, falses}) do
    if pred.(x) do {[x | trues], falses} else {trues, [x | falses]} end
  end

  @doc """
  Combine two lists, combining them with the given function.
  If one list is longer, the extra elements are dropped.
  
  
      iex> import Elmchemy.XList
      iex> map2.((&+/0).()).([1, 2, 3]).([1, 2, 3, 4])
      [2, 4, 6]
  
  
      iex> import Elmchemy.XList
      iex> map2.((&tuple2/0).()).([1, 2, 3]).(['a', 'b'])
      [{1, 'a'}, {2, 'b'}]
  
  
 
  """
  @spec map2() :: ((any -> (any -> Elmchemy.XResult.result)) -> (list(any) -> (list(any) -> list(Elmchemy.XResult.result))))
  @spec map2((any -> (any -> Elmchemy.XResult.result)), list(any), list(any)) :: list(Elmchemy.XResult.result)
  curry map2/3
  def map2(f, a, b) do
    zip_.(a).(b)
    |> (map.(uncurried.(f))).()
  end

  @spec zip_() :: (list(any) -> (list(any) -> list({any, any})))
  @spec zip_(list(any), list(any)) :: list({any, any})
  curryp zip_/2
  verify as: Enum.zip/2
  def zip_(a1, a2), do: Enum.zip(a1, a2)
  #  {-|-}
  #  map3 : (a -> b -> c -> result) -> List a -> List b -> List c -> List result
  #  map3 =
  #    Native.List.map3
  #  {-|-}
  #  map4 : (a -> b -> c -> d -> result) -> List a -> List b -> List c -> List d -> List result
  #  map4 =
  #    Native.List.map4
  #  {-|-}
  #  map5 : (a -> b -> c -> d -> e -> result) -> List a -> List b -> List c -> List d -> List e -> List result
  #  map5 =
  #    Native.List.map5
  @doc """
  Decompose a list of tuples into a tuple of lists.
  
  
      iex> import Elmchemy.XList
      iex> unzip.(repeat.(3).({0, :true}))
      {[0, 0, 0], [:true, :true, :true]}
  
  
 
  """
  @spec unzip() :: (list({any, any}) -> {list(any), list(any)})
  @spec unzip(list({any, any})) :: {list(any), list(any)}
  curry unzip/1
  def unzip(pairs) do
    foldr.(unzip_step).({[], []}).(pairs)
  end

  @spec unzip_step() :: ({any, any} -> ({list(any), list(any)} -> {list(any), list(any)}))
  @spec unzip_step({any, any}, {list(any), list(any)}) :: {list(any), list(any)}
  curryp unzip_step/2
  defp unzip_step({x, y}, {xs, ys}) do
    {[x | xs], [y | ys]}
  end

  @doc """
  Places the given value between all members of the given list.
  
  
      iex> import Elmchemy.XList
      iex> intersperse.("on").(["turtles", "turtles", "turtles"])
      ["turtles", "on", "turtles", "on", "turtles"]
  
  
 
  """
  @spec intersperse() :: (any -> (list(any) -> list(any)))
  @spec intersperse(any, list(any)) :: list(any)
  curry intersperse/2
  def intersperse(sep, xs) do
    case xs do
      [] -> []
      [hd | tl] -> step = fn(x) -> fn(rest) -> [sep | [x | rest]] end end
    spersed = foldr.(step).([]).(tl)
    [hd | spersed]
    end
  end

  @doc """
  Take the first *n* members of a list.
  
  
      iex> import Elmchemy.XList
      iex> take.(2).([1, 2, 3, 4])
      [1, 2]
  
  
 
  """
  @spec take() :: (integer -> (list(any) -> list(any)))
  @spec take(integer, list(any)) :: list(any)
  curry take/2
  def take(n, list) do
    take_fast.(0).(n).(list)
  end

  @spec take_fast() :: (integer -> (integer -> (list(any) -> list(any))))
  @spec take_fast(integer, integer, list(any)) :: list(any)
  curryp take_fast/3
  defp take_fast(ctr, n, list) do
    if n <= 0 do [] else case {n, list} do
      {_, []} -> list
      {1, [x | _]} -> [x]
      {2, [x | [y | _]]} -> [x, y]
      {3, [x | [y | [z | _]]]} -> [x, y, z]
      {_, [x | [y | [z | [w | tl]]]]} -> if ctr > 1000 do [x | [y | [z | [w | take_tail_rec.(n - 4).(tl)]]]] else [x | [y | [z | [w | take_fast.(ctr + 1).(n - 4).(tl)]]]] end
      _ -> list
    end end
  end

  @spec take_tail_rec() :: (integer -> (list(any) -> list(any)))
  @spec take_tail_rec(integer, list(any)) :: list(any)
  curryp take_tail_rec/2
  defp take_tail_rec(n, list) do
    reverse.(take_reverse.(n).(list).([]))
  end

  @spec take_reverse() :: (integer -> (list(any) -> (list(any) -> list(any))))
  @spec take_reverse(integer, list(any), list(any)) :: list(any)
  curryp take_reverse/3
  defp take_reverse(n, list, taken) do
    if n <= 0 do taken else case list do
      [] -> taken
      [x | xs] -> take_reverse.(n - 1).(xs).([x | taken])
    end end
  end

  @doc """
  Drop the first *n* members of a list.
  
  
      iex> import Elmchemy.XList
      iex> drop.(2).([1, 2, 3, 4])
      [3, 4]
  
  
 
  """
  @spec drop() :: (integer -> (list(any) -> list(any)))
  @spec drop(integer, list(any)) :: list(any)
  curry drop/2
  def drop(n, list) do
    if n <= 0 do list else case list do
      [] -> list
      [x | xs] -> drop.(n - 1).(xs)
    end end
  end

  @doc """
  Create a list with only one element:
  
  
      iex> import Elmchemy.XList
      iex> singleton.(1234)
      [1234]
  
      iex> import Elmchemy.XList
      iex> singleton.("hi")
      ["hi"]
  
  
 
  """
  @spec singleton() :: (any -> list(any))
  @spec singleton(any) :: list(any)
  curry singleton/1
  def singleton(value) do
    [value]
  end

  @doc """
  Create a list with *n* copies of a value:
  
  
      iex> import Elmchemy.XList
      iex> repeat.(3).(0)
      [0, 0, 0]
  
  
 
  """
  @spec repeat() :: (integer -> (any -> list(any)))
  @spec repeat(integer, any) :: list(any)
  curry repeat/2
  def repeat(n, value) do
    repeat_help.([]).(n).(value)
  end

  @spec repeat_help() :: (list(any) -> (integer -> (any -> list(any))))
  @spec repeat_help(list(any), integer, any) :: list(any)
  curryp repeat_help/3
  defp repeat_help(result, n, value) do
    if n <= 0 do result else repeat_help.([value | result]).(n - 1).(value) end
  end

  @doc """
  Create a list of numbers, every element increasing by one.
  You give the lowest and highest number that should be in the list.
  
  
      iex> import Elmchemy.XList
      iex> range.(3).(6)
      [3, 4, 5, 6]
  
      iex> import Elmchemy.XList
      iex> range.(3).(3)
      [3]
  
      iex> import Elmchemy.XList
      iex> range.(6).(3)
      []
  
  
 
  """
  @spec range() :: (integer -> (integer -> list(integer)))
  @spec range(integer, integer) :: list(integer)
  curry range/2
  def range(lo, hi) do
    range_help.(lo).(hi).([])
  end

  @spec range_help() :: (integer -> (integer -> (list(integer) -> list(integer))))
  @spec range_help(integer, integer, list(integer)) :: list(integer)
  curryp range_help/3
  defp range_help(lo, hi, list) do
    if lo <= hi do range_help.(lo).(hi - 1).([hi | list]) else list end
  end

  @doc """
  Sort values from lowest to highest
  
  
      iex> import Elmchemy.XList
      iex> sort.([3, 1, 5])
      [1, 3, 5]
  
  
 
  """
  @spec sort() :: (list(any) -> list(any))
  @spec sort(list(any)) :: list(any)
  curry sort/1
  def sort(xs) do
    sort_by.(identity).(xs)
  end

  @doc """
  Sort values by a derived property. To be replaced
  
  
      iex> import Elmchemy.XList
      iex> sort_by.(fn({i, a}) -> i end).([{1, "mouse"}, {0, "cat"}])
      [{0, "cat"}, {1, "mouse"}]
  
  
 
  """
  @spec sort_by() :: ((any -> any) -> (list(any) -> list(any)))
  @spec sort_by((any -> any), list(any)) :: list(any)
  curry sort_by/2
  def sort_by(f, list) do
    sort_with.(fn(a) -> fn(b) -> compare.(f.(a)).(f.(b)) end end).(list)
  end

  @doc """
  Sort values with a custom comparison function.
  
  
      iex> import Elmchemy.XList
      iex> sort_with.(flip.(compare)).([1, 2, 3, 4, 5])
      [5, 4, 3, 2, 1]
  
  This is also the most general sort function, allowing you
  to define any other: `sort == sortWith compare`
  f
  
  
 
  """
  @spec sort_with() :: ((any -> (any -> Elmchemy.XBasics.order)) -> (list(any) -> list(any)))
  @spec sort_with((any -> (any -> Elmchemy.XBasics.order)), list(any)) :: list(any)
  curry sort_with/2
  def sort_with(f, list) do
    exf = fn(a) -> fn(b) -> f.(a).(b)
    |> (fn(a) -> case a do
      :gt -> :false
      :eq -> :false
      :lt -> :true
    end end).() end end
    sort_.(list).(exf)
  end

  @spec sort_() :: (list(any) -> ((any -> (any -> boolean)) -> list(any)))
  @spec sort_(list(any), (any -> (any -> boolean))) :: list(any)
  curryp sort_/2
  verify as: Enum.sort/2
  def sort_(a1, a2), do: Enum.sort(a1, fn (x1,x2) -> a2.(x1).(x2) end)
end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XMaybe.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XMaybe do
  use Elmchemy

  @doc """
  This library fills a bunch of important niches in Elm. A `Maybe` can help
  you with optional arguments, error handling, and records with optional fields.
  
  
  # Definition
  
  @docs Maybe
  
  
  # Common Helpers
  
  @docs withDefault, map, map2, map3, map4, map5
  
  
  # Chaining Maybes
  
  @docs andThen
  
  
 
  """
  @doc """
  Represent values that may or may not exist. It can be useful if you have a
  record field that is only filled in sometimes. Or if a function takes a value
  sometimes, but does not absolutely need it.
  
 
  """
  @type maybe :: any | nil
  @doc """
  Provide a default value, turning an optional value into a normal
  value. This comes in handy when paired with functions like
  [`Dict.get`](Dict#get) which gives back a `Maybe`.
  
  
      iex> import Elmchemy.XMaybe
      iex> with_default.(100).({42})
      42
  
      iex> import Elmchemy.XMaybe
      iex> with_default.(100).(nil)
      100
  
  
 
  """
  @spec with_default() :: (any -> (any | nil -> any))
  @spec with_default(any, any | nil) :: any
  curry with_default/2
  def with_default(default, maybe) do
    case maybe do
      nil -> default
      {value} -> value
    end
  end

  @doc """
  Transform a `Maybe` value with a given function:
  
  
      iex> import Elmchemy.XMaybe
      iex> map.((&+/0).().(2)).({9})
      {11}
  
      iex> import Elmchemy.XMaybe
      iex> map.((&+/0).().(2)).(nil)
      nil
  
  
 
  """
  @spec map() :: ((any -> any) -> (any | nil -> any | nil))
  curry map/2
  def map(f, maybe) do
    case maybe do
      nil -> nil
      {value} -> {f.(value)}
    end
  end

  @doc """
  Apply a function if all the arguments are `Just` a value.
  
  
      iex> import Elmchemy.XMaybe
      iex> map2.((&+/0).()).({3}).({4})
      {7}
  
      iex> import Elmchemy.XMaybe
      iex> map2.((&+/0).()).({3}).(nil)
      nil
  
      iex> import Elmchemy.XMaybe
      iex> map2.((&+/0).()).(nil).({4})
      nil
  
  
 
  """
  @spec map2() :: ((any -> (any -> any)) -> (any | nil -> (any | nil -> any | nil)))
  curry map2/3
  def map2(func, ma, mb) do
    case {ma, mb} do
      {{a}, {b}} -> {func.(a).(b)}
      _ -> nil
    end
  end

  @doc """
 
 
  """
  @spec map3() :: ((any -> (any -> (any -> any))) -> (any | nil -> (any | nil -> (any | nil -> any | nil))))
  curry map3/4
  def map3(func, ma, mb, mc) do
    case {ma, mb, mc} do
      {{a}, {b}, {c}} -> {func.(a).(b).(c)}
      _ -> nil
    end
  end

  @doc """
 
 
  """
  @spec map4() :: ((any -> (any -> (any -> (any -> any)))) -> (any | nil -> (any | nil -> (any | nil -> (any | nil -> any | nil)))))
  curry map4/5
  def map4(func, ma, mb, mc, md) do
    case {ma, mb, mc, md} do
      {{a}, {b}, {c}, {d}} -> {func.(a).(b).(c).(d)}
      _ -> nil
    end
  end

  @doc """
 
 
  """
  @spec map5() :: ((any -> (any -> (any -> (any -> (any -> any))))) -> (any | nil -> (any | nil -> (any | nil -> (any | nil -> (any | nil -> any | nil))))))
  curry map5/6
  def map5(func, ma, mb, mc, md, me) do
    case {ma, mb, mc, md, me} do
      {{a}, {b}, {c}, {d}, {e}} -> {func.(a).(b).(c).(d).(e)}
      _ -> nil
    end
  end

  @doc """
  Chain together many computations that may fail. It is helpful to see its
  definition:
  
  This means we only continue with the callback if things are going well. For
  example, say you need to use (`head : List Int -> Maybe Int`) to get the
  first month from a `List` and then make sure it is between 1 and 12:
  
  If `head` fails and results in `Nothing` (because the `List` was `empty`),
  this entire chain of operations will short-circuit and result in `Nothing`.
  If `toValidMonth` results in `Nothing`, again the chain of computations
  will result in `Nothing`.
  
  
 
  """
  @spec and_then() :: ((any -> any | nil) -> (any | nil -> any | nil))
  curry and_then/2
  def and_then(callback, maybe_value) do
    case maybe_value do
      {value} -> callback.(value)
      nil -> nil
    end
  end

end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XResult.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XResult do
  use Elmchemy

  @doc """
  A `Result` is the result of a computation that may fail. This is a great
  way to manage errors in Elm.
  
  
  # Type and Constructors
  
  @docs Result
  
  
  # Mapping
  
  @docs map, map2, map3, map4, map5
  
  
  # Chaining
  
  @docs andThen
  
  
  # Handling Errors
  
  @docs withDefault, toMaybe, fromMaybe, mapError
  
  
 
  """
  import Elmchemy
  @doc """
  A `Result` is either `Ok` meaning the computation succeeded, or it is an
  `Err` meaning that there was some failure.
  
 
  """
  @type result :: {:ok,any} | {:error, any}
  @doc """
  If the result is `Ok` return the value, but if the result is an `Err` then
  return a given default value. The following examples try to parse integers.
  
  
      iex> import Elmchemy.XResult
      iex> XResult.with_default.(0).(XString.to_int.("123"))
      123
  
      iex> import Elmchemy.XResult
      iex> XResult.with_default.(0).(XString.to_int.("abc"))
      0
  
  
 
  """
  @spec with_default() :: (any -> (result -> any))
  @spec with_default(any, result) :: any
  curry with_default/2
  def with_default(def, result) do
    case result do
      {:ok, a} -> a
      {:error, _} -> def
    end
  end

  @doc """
  Apply a function to a result. If the result is `Ok`, it will be converted.
  If the result is an `Err`, the same error value will propagate through.
  
  
      iex> import Elmchemy.XResult
      iex> map.(sqrt).({:ok, 4.0})
      {:ok, 2.0}
  
      iex> import Elmchemy.XResult
      iex> map.(sqrt).({:error, "bad input"})
      {:error, "bad input"}
  
  
 
  """
  @spec map() :: ((any -> any) -> (result -> result))
  @spec map((any -> any), result) :: result
  curry map/2
  def map(func, ra) do
    case ra do
      {:ok, a} -> {:ok, func.(a)}
      {:error, e} -> {:error, e}
    end
  end

  @doc """
  Apply a function to two results, if both results are `Ok`. If not,
  the first argument which is an `Err` will propagate through.
  
  
      iex> import Elmchemy.XResult
      iex> map2.((&+/0).()).(XString.to_int.("1")).(XString.to_int.("2"))
      {:ok, 3}
  
      iex> import Elmchemy.XResult
      iex> map2.((&+/0).()).(XString.to_int.("1")).(XString.to_int.("y"))
      {:error, "could not convert string 'y' to an Int"}
  
      iex> import Elmchemy.XResult
      iex> map2.((&+/0).()).(XString.to_int.("x")).(XString.to_int.("y"))
      {:error, "could not convert string 'x' to an Int"}
  
  
 
  """
  @spec map2() :: ((any -> (any -> any)) -> (result -> (result -> result)))
  @spec map2((any -> (any -> any)), result, result) :: result
  curry map2/3
  def map2(func, ra, rb) do
    case {ra, rb} do
      {{:ok, a}, {:ok, b}} -> {:ok, func.(a).(b)}
      {{:error, x}, _} -> {:error, x}
      {_, {:error, x}} -> {:error, x}
    end
  end

  @doc """
 
 
  """
  @spec map3() :: ((any -> (any -> (any -> any))) -> (result -> (result -> (result -> result))))
  @spec map3((any -> (any -> (any -> any))), result, result, result) :: result
  curry map3/4
  def map3(func, ra, rb, rc) do
    case {ra, rb, rc} do
      {{:ok, a}, {:ok, b}, {:ok, c}} -> {:ok, func.(a).(b).(c)}
      {{:error, x}, _, _} -> {:error, x}
      {_, {:error, x}, _} -> {:error, x}
      {_, _, {:error, x}} -> {:error, x}
    end
  end

  @doc """
 
 
  """
  @spec map4() :: ((any -> (any -> (any -> (any -> any)))) -> (result -> (result -> (result -> (result -> result)))))
  @spec map4((any -> (any -> (any -> (any -> any)))), result, result, result, result) :: result
  curry map4/5
  def map4(func, ra, rb, rc, rd) do
    case {ra, rb, rc, rd} do
      {{:ok, a}, {:ok, b}, {:ok, c}, {:ok, d}} -> {:ok, func.(a).(b).(c).(d)}
      {{:error, x}, _, _, _} -> {:error, x}
      {_, {:error, x}, _, _} -> {:error, x}
      {_, _, {:error, x}, _} -> {:error, x}
      {_, _, _, {:error, x}} -> {:error, x}
    end
  end

  @doc """
 
 
  """
  @spec map5() :: ((any -> (any -> (any -> (any -> (any -> any))))) -> (result -> (result -> (result -> (result -> (result -> result))))))
  @spec map5((any -> (any -> (any -> (any -> (any -> any))))), result, result, result, result, result) :: result
  curry map5/6
  def map5(func, ra, rb, rc, rd, re) do
    case {ra, rb, rc, rd, re} do
      {{:ok, a}, {:ok, b}, {:ok, c}, {:ok, d}, {:ok, e}} -> {:ok, func.(a).(b).(c).(d).(e)}
      {{:error, x}, _, _, _, _} -> {:error, x}
      {_, {:error, x}, _, _, _} -> {:error, x}
      {_, _, {:error, x}, _, _} -> {:error, x}
      {_, _, _, {:error, x}, _} -> {:error, x}
      {_, _, _, _, {:error, x}} -> {:error, x}
    end
  end

  @doc """
  Chain together a sequence of computations that may fail. It is helpful
  to see its definition:
  
  This means we only continue with the callback if things are going well. For
  example, say you need to use (`toInt : String -> Result String Int`) to parse
  a month and make sure it is between 1 and 12:
  
  This allows us to come out of a chain of operations with quite a specific error
  message. It is often best to create a custom type that explicitly represents
  the exact ways your computation may fail. This way it is easy to handle in your
  code.
  
  
 
  """
  @spec and_then() :: ((any -> result) -> (result -> result))
  @spec and_then((any -> result), result) :: result
  curry and_then/2
  def and_then(callback, result) do
    case result do
      {:ok, value} -> callback.(value)
      {:error, msg} -> {:error, msg}
    end
  end

  @doc """
  Transform an `Err` value. For example, say the errors we get have too much
  information:
  
  
      iex> import Elmchemy.XResult
      iex> map_error.(XTuple.first).({:ok, {123, 1}})
      {:ok, {123, 1}}
  
      iex> import Elmchemy.XResult
      iex> map_error.(XTuple.second).({:error, {"nothing", "important"}})
      {:error, "important"}
  
  
 
  """
  @spec map_error() :: ((any -> any) -> (result -> result))
  @spec map_error((any -> any), result) :: result
  curry map_error/2
  def map_error(f, result) do
    case result do
      {:ok, v} -> {:ok, v}
      {:error, e} -> {:error, f.(e)}
    end
  end

  @doc """
  Convert to a simpler `Maybe` if the actual error message is not needed or
  you need to interact with some code that primarily uses maybes.
  
 
  """
  @spec to_maybe() :: (result -> any | nil)
  @spec to_maybe(result) :: any | nil
  curry to_maybe/1
  def to_maybe({:ok, v}) do
    {v}
  end
  def to_maybe({:error, _}) do
    nil
  end

  @doc """
  Convert from a simple `Maybe` to interact with some code that primarily
  uses `Results`.
  
 
  """
  @spec from_maybe() :: (any -> (any | nil -> result))
  @spec from_maybe(any, any | nil) :: result
  curry from_maybe/2
  def from_maybe(err, maybe) do
    case maybe do
      {v} -> {:ok, v}
      nil -> {:error, err}
    end
  end

end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XString.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XString do
  use Elmchemy

  @doc """
  A built-in representation for efficient string manipulation. String literals
  are enclosed in `"double quotes"`. Strings are *not* lists of characters.
  
  
  # Basics
  
  @docs isEmpty, length, reverse, repeat
  
  
  # Building and Splitting
  
  @docs cons, uncons, fromChar, append, concat, split, join, words, lines
  
  
  # Get Substrings
  
  @docs slice, left, right, dropLeft, dropRight
  
  
  # Check for Substrings
  
  @docs contains, startsWith, endsWith, indexes, indices
  
  
  # Conversions
  
  @docs toInt, toFloat, toList, fromList
  
  
  # Formatting
  
  Cosmetic operations such as padding with extra characters or trimming whitespace.
  
  @docs toUpper, toLower, pad, padLeft, padRight, trim, trimLeft, trimRight
  
  
  # Higher-Order Functions
  
  @docs map, filter, foldl, foldr, any, all
  
  
 
  """
  import Elmchemy
  alias Elmchemy.XResult, as: XResult
  alias Elmchemy.XList, as: XList
  alias Elmchemy.XTuple, as: XTuple

  import Kernel, except: [
  {:length, 1},
  {:'++', 2},
  {:to_charlist, 1}

  ]
  import Elmchemy.XBasics, except: [
  {:to_float, 1},
  ]

  @doc """
  Determine if a string is empty.
  
  
      iex> import Elmchemy.XString
      iex> is_empty.("")
      :true
  
      iex> import Elmchemy.XString
      iex> is_empty.("the world")
      :false
  
  
 
  """
  @spec is_empty() :: (String.t -> boolean)
  @spec is_empty(String.t) :: boolean
  curry is_empty/1
  def is_empty(str) do
    length.(str) == 0
  end

  @doc """
  Add a character to the beginning of a string.
  
  
      iex> import Elmchemy.XString
      iex> XString.cons.('T').("he truth is out there")
      "The truth is out there"
  
  
 
  """
  @spec cons() :: (char_list -> (String.t -> String.t))
  @spec cons(char_list, String.t) :: String.t
  curry cons/2
  def cons(c, str) do
    from_char.(c) ++ str
  end

  @doc """
  Create a string from a given character.
  
  
      iex> import Elmchemy.XString
      iex> from_char.('a')
      "a"
  
  
 
  """
  @spec from_char() :: (char_list -> String.t)
  @spec from_char(char_list) :: String.t
  curry from_char/1
  verify as: :binary.list_to_bin/1
  def from_char(a1), do: :binary.list_to_bin(a1)
  @doc """
  Split a non-empty string into its head and tail. This lets you
  pattern match on strings exactly as you would with lists.
  
  
      iex> import Elmchemy.XString
      iex> uncons.("abc")
      {{'a', "bc"}}
  
      iex> import Elmchemy.XString
      iex> uncons.("")
      nil
  
  
 
  """
  @spec uncons() :: (String.t -> {char_list, String.t} | nil)
  @spec uncons(String.t) :: {char_list, String.t} | nil
  curry uncons/1
  def uncons(str) do
    {first, rest} = split_at_.(str).(1)
    real_first = first
    |> (to_list).()
    case real_first do
      [] -> nil
      [r] -> {{r, rest}}
      _ -> nil
    end
  end

  @spec split_at_() :: (String.t -> (integer -> {String.t, String.t}))
  @spec split_at_(String.t, integer) :: {String.t, String.t}
  curryp split_at_/2
  verify as: String.split_at/2
  def split_at_(a1, a2), do: String.split_at(a1, a2)
  @doc """
  Append two strings. You can also use [the `(++)` operator](Basics#++)
  to do this.
  
  
      iex> import Elmchemy.XString
      iex> append.("butter").("fly")
      "butterfly"
  
  
 
  """
  @spec append() :: (String.t -> (String.t -> String.t))
  @spec append(String.t, String.t) :: String.t
  curry append/2
  def append(a, b) do
    a ++ b
  end

  @doc """
  Concatenate many strings into one.
  
  
      iex> import Elmchemy.XString
      iex> concat.(["never", "the", "less"])
      "nevertheless"
  
  
 
  """
  @spec concat() :: (list(String.t) -> String.t)
  @spec concat(list(String.t)) :: String.t
  curry concat/1
  def concat(list) do
    XList.foldr.((&++/0).()).("").(list)
  end

  @doc """
  Get the length of a string.
  
  
      iex> import Elmchemy.XString
      iex> length.("innumerable")
      11
  
      iex> import Elmchemy.XString
      iex> length.("")
      0
  
  
 
  """
  @spec length() :: (String.t -> integer)
  @spec length(String.t) :: integer
  curry length/1
  verify as: String.length/1
  def length(a1), do: String.length(a1)
  @doc """
  Transform every character in a string
  
  
      iex> import Elmchemy.XString
      iex> map.(fn(c) -> if c == '/' do '.' else c end end).("a/b/c")
      "a.b.c"
  
  
 
  """
  @spec map() :: ((char_list -> char_list) -> (String.t -> String.t))
  curry map/2
  def map(f, str) do
    str
    |> (to_list).()
    |> (fn(str) -> XList.map.(f).(str) end).()
    |> (XList.map.(from_char)).()
    |> (join.("")).()
  end

  @doc """
  Keep only the characters that satisfy the predicate.
  
  
      iex> import Elmchemy.XString
      iex> filter.((&==/0).().('2')).("R2-D2")
      "22"
  
  
 
  """
  @spec filter() :: ((char_list -> boolean) -> (String.t -> String.t))
  curry filter/2
  def filter(f, str) do
    str
    |> (to_list).()
    |> (fn(str) -> XList.filter.(f).(str) end).()
    |> (XList.map.(from_char)).()
    |> (join.("")).()
  end

  @doc """
  Reverse a string.
  
  
      iex> import Elmchemy.XString
      iex> reverse.("stressed")
      "desserts"
  
  
 
  """
  @spec reverse() :: (String.t -> String.t)
  @spec reverse(String.t) :: String.t
  curry reverse/1
  verify as: String.reverse/1
  def reverse(a1), do: String.reverse(a1)
  @doc """
  Reduce a string from the left.
  
  
      iex> import Elmchemy.XString
      iex> foldl.(XString.cons).("").("time")
      "emit"
  
  
 
  """
  @spec foldl() :: ((char_list -> (any -> any)) -> (any -> (String.t -> any)))
  curry foldl/3
  def foldl(f, acc, str) do
    str
    |> (to_list).()
    |> (XList.foldl.(f).(acc)).()
  end

  @doc """
  Reduce a string from the right.
  
  
      iex> import Elmchemy.XString
      iex> foldr.(XString.cons).("").("time")
      "time"
  
  
 
  """
  @spec foldr() :: ((char_list -> (any -> any)) -> (any -> (String.t -> any)))
  curry foldr/3
  def foldr(f, acc, str) do
    str
    |> (to_list).()
    |> (XList.foldr.(f).(acc)).()
  end

  @doc """
  Split a string using a given separator.
  
  
      iex> import Elmchemy.XString
      iex> split.(",").("cat,dog,cow")
      ["cat", "dog", "cow"]
  
      iex> import Elmchemy.XString
      iex> split.("/").("home/evan/Desktop/")
      ["home", "evan", "Desktop", ""]
  
  Use [`Regex.split`](Regex#split) if you need something more flexible.
  
  
 
  """
  @spec split() :: (String.t -> (String.t -> list(String.t)))
  @spec split(String.t, String.t) :: list(String.t)
  curry split/2
  def split(pattern, str) do
    split_.(str).([pattern]).([])
  end

  @type split_option :: {:trim, boolean}
  @spec split_() :: (String.t -> (list(String.t) -> (list(split_option) -> list(String.t))))
  @spec split_(String.t, list(String.t), list(split_option)) :: list(String.t)
  curryp split_/3
  verify as: String.split/3
  def split_(a1, a2, a3), do: String.split(a1, a2, a3)
  @doc """
  Put many strings together with a given separator.
  
  
      iex> import Elmchemy.XString
      iex> join.("a").(["H", "w", "ii", "n"])
      "Hawaiian"
  
      iex> import Elmchemy.XString
      iex> join.(" ").(["cat", "dog", "cow"])
      "cat dog cow"
  
      iex> import Elmchemy.XString
      iex> join.("/").(["home", "evan", "Desktop"])
      "home/evan/Desktop"
  
  
 
  """
  @spec join() :: (String.t -> (list(String.t) -> String.t))
  @spec join(String.t, list(String.t)) :: String.t
  curry join/2
  def join(str, list) do
    join_.(list).(str)
  end

  @spec join_() :: (list(String.t) -> (String.t -> String.t))
  @spec join_(list(String.t), String.t) :: String.t
  curryp join_/2
  verify as: Enum.join/2
  def join_(a1, a2), do: Enum.join(a1, a2)
  @doc """
  Repeat a string *n* times.
  
  
      iex> import Elmchemy.XString
      iex> repeat.(3).("ha")
      "hahaha"
  
  
 
  """
  @spec repeat() :: (integer -> (String.t -> String.t))
  @spec repeat(integer, String.t) :: String.t
  curry repeat/2
  def repeat(n, str) do
    repeat_.(str).(n)
  end

  @spec repeat_() :: (String.t -> (integer -> String.t))
  @spec repeat_(String.t, integer) :: String.t
  curryp repeat_/2
  verify as: String.duplicate/2
  def repeat_(a1, a2), do: String.duplicate(a1, a2)
  @doc """
  Take a substring given a start and end index. Negative indexes
  are taken starting from the *end* of the list.
  
  
      iex> import Elmchemy.XString
      iex> slice.(7).(9).("snakes on a plane!")
      "on"
  
      iex> import Elmchemy.XString
      iex> slice.(0).(6).("snakes on a plane!")
      "snakes"
  
      iex> import Elmchemy.XString
      iex> slice.(0).(-7).("snakes on a plane!")
      "snakes on a"
  
      iex> import Elmchemy.XString
      iex> slice.(-6).(-1).("snakes on a plane!")
      "plane"
  
  
 
  """
  #  slice 7 9 = slice 7 (9 - 7)
  #                      7  2
  #  slice 0 6 = slice 0 (6 - 0)
  #                      0 6
  #  slice 0 -7 = slice 0 (18 - 7 - 0)
  #                       0  11
  #  slice -6 -1 = slice ((18 - 6)) (18 - 1 - 12)
  #                           12       5
  @spec slice() :: (integer -> (integer -> (String.t -> String.t)))
  @spec slice(integer, integer, String.t) :: String.t
  curry slice/3
  def slice(from, to, str) do
    l = length.(str)
    mirror = fn(a) -> if a < 0 do l + a else a end end
    start = mirror.(from)
    len = mirror.(to) - start
    slice_.(str).(start).(len)
  end

  @spec slice_() :: (String.t -> (integer -> (integer -> String.t)))
  @spec slice_(String.t, integer, integer) :: String.t
  curryp slice_/3
  verify as: String.slice/3
  def slice_(a1, a2, a3), do: String.slice(a1, a2, a3)
  @doc """
  Take *n* characters from the left side of a string.
  
  
      iex> import Elmchemy.XString
      iex> left.(2).("Mulder")
      "Mu"
  
  
 
  """
  @spec left() :: (integer -> (String.t -> String.t))
  @spec left(integer, String.t) :: String.t
  curry left/2
  def left(n, str) do
    slice.(0).(n).(str)
  end

  @doc """
  Take *n* characters from the right side of a string.
  
  
      iex> import Elmchemy.XString
      iex> right.(2).("Scully")
      "ly"
  
  
 
  """
  @spec right() :: (integer -> (String.t -> String.t))
  @spec right(integer, String.t) :: String.t
  curry right/2
  def right(n, str) do
    slice.(negate.(n)).(length.(str)).(str)
  end

  @doc """
  Drop *n* characters from the left side of a string.
  
  
      iex> import Elmchemy.XString
      iex> drop_left.(2).("The Lone Gunmen")
      "e Lone Gunmen"
  
  
 
  """
  @spec drop_left() :: (integer -> (String.t -> String.t))
  @spec drop_left(integer, String.t) :: String.t
  curry drop_left/2
  def drop_left(n, str) do
    slice.(n).(length.(str)).(str)
  end

  @doc """
  Drop *n* characters from the right side of a string.
  
  
      iex> import Elmchemy.XString
      iex> drop_right.(2).("Cigarette Smoking Man")
      "Cigarette Smoking M"
  
  
 
  """
  @spec drop_right() :: (integer -> (String.t -> String.t))
  @spec drop_right(integer, String.t) :: String.t
  curry drop_right/2
  def drop_right(n, str) do
    slice.(0).(negate.(n)).(str)
  end

  @doc """
  Pad a string on both sides until it has a given length.
  
  
      iex> import Elmchemy.XString
      iex> pad.(5).(' ').("1")
      "  1  "
  
      iex> import Elmchemy.XString
      iex> pad.(5).(' ').("11")
      "  11 "
  
      iex> import Elmchemy.XString
      iex> pad.(5).(' ').("121")
      " 121 "
  
  
 
  """
  @spec pad() :: (integer -> (char_list -> (String.t -> String.t)))
  @spec pad(integer, char_list, String.t) :: String.t
  curry pad/3
  def pad(n, c, str) do
    right = div(length.(str) + n, 2)
    left = n
    str
    |> (pad_right.(right).(c)).()
    |> (pad_left.(left).(c)).()
  end

  @doc """
  Pad a string on the left until it has a given length.
  
  
      iex> import Elmchemy.XString
      iex> pad_left.(5).('.').("1")
      "....1"
  
      iex> import Elmchemy.XString
      iex> pad_left.(5).('.').("11")
      "...11"
  
      iex> import Elmchemy.XString
      iex> pad_left.(5).('.').("121")
      "..121"
  
  
 
  """
  @spec pad_left() :: (integer -> (char_list -> (String.t -> String.t)))
  @spec pad_left(integer, char_list, String.t) :: String.t
  curry pad_left/3
  def pad_left(n, c, str) do
    pad_leading.(str).(n).(from_char.(c))
  end

  @spec pad_leading() :: (String.t -> (integer -> (String.t -> String.t)))
  @spec pad_leading(String.t, integer, String.t) :: String.t
  curryp pad_leading/3
  verify as: String.pad_leading/3
  def pad_leading(a1, a2, a3), do: String.pad_leading(a1, a2, a3)
  @doc """
  Pad a string on the right until it has a given length.
  
  
      iex> import Elmchemy.XString
      iex> pad_right.(5).('.').("1")
      "1...."
  
      iex> import Elmchemy.XString
      iex> pad_right.(5).('.').("11")
      "11..."
  
      iex> import Elmchemy.XString
      iex> pad_right.(5).('.').("121")
      "121.."
  
  
 
  """
  @spec pad_right() :: (integer -> (char_list -> (String.t -> String.t)))
  @spec pad_right(integer, char_list, String.t) :: String.t
  curry pad_right/3
  def pad_right(n, c, str) do
    pad_trailing.(str).(n).(from_char.(c))
  end

  @spec pad_trailing() :: (String.t -> (integer -> (String.t -> String.t)))
  @spec pad_trailing(String.t, integer, String.t) :: String.t
  curryp pad_trailing/3
  verify as: String.pad_trailing/3
  def pad_trailing(a1, a2, a3), do: String.pad_trailing(a1, a2, a3)
  @doc """
  Get rid of whitespace on both sides of a string.
  
  
      iex> import Elmchemy.XString
      iex> trim.("  hats  \\n")
      "hats"
  
  
 
  """
  @spec trim() :: (String.t -> String.t)
  @spec trim(String.t) :: String.t
  curry trim/1
  verify as: String.trim/1
  def trim(a1), do: String.trim(a1)
  @doc """
  Get rid of whitespace on the left of a string.
  
  
      iex> import Elmchemy.XString
      iex> trim_left.("  hats  \\n")
      "hats  \\n"
  
  
 
  """
  @spec trim_left() :: (String.t -> String.t)
  @spec trim_left(String.t) :: String.t
  curry trim_left/1
  verify as: String.trim_leading/1
  def trim_left(a1), do: String.trim_leading(a1)
  @doc """
  Get rid of whitespace on the right of a string.
  
  
      iex> import Elmchemy.XString
      iex> trim_right.("  hats  \\n")
      "  hats"
  
  
 
  """
  @spec trim_right() :: (String.t -> String.t)
  @spec trim_right(String.t) :: String.t
  curry trim_right/1
  verify as: String.trim_trailing/1
  def trim_right(a1), do: String.trim_trailing(a1)
  @doc """
  Break a string into words, splitting on chunks of whitespace.
  
  
      iex> import Elmchemy.XString
      iex> words.("How are \t you? \\n Good?")
      ["How", "are", "you?", "Good?"]
  
  
 
  """
  @spec words() :: (String.t -> list(String.t))
  @spec words(String.t) :: list(String.t)
  curry words/1
  verify as: String.split/1
  def words(a1), do: String.split(a1)
  @doc """
  Break a string into lines, splitting on newlines.
  
  
      iex> import Elmchemy.XString
      iex> lines.("How are you?\\nGood?")
      ["How are you?", "Good?"]
  
  
 
  """
  @spec lines() :: (String.t -> list(String.t))
  @spec lines(String.t) :: list(String.t)
  curry lines/1
  def lines(str) do
    split.("\n").(str)
  end

  @doc """
  Convert a string to all upper case. Useful for case-insensitive comparisons
  and VIRTUAL YELLING.
  
  
      iex> import Elmchemy.XString
      iex> to_upper.("skinner")
      "SKINNER"
  
  
 
  """
  @spec to_upper() :: (String.t -> String.t)
  @spec to_upper(String.t) :: String.t
  curry to_upper/1
  verify as: String.upcase/1
  def to_upper(a1), do: String.upcase(a1)
  @doc """
  Convert a string to all lower case. Useful for case-insensitive comparisons.
  
  
      iex> import Elmchemy.XString
      iex> to_lower.("X-FILES")
      "x-files"
  
  
 
  """
  @spec to_lower() :: (String.t -> String.t)
  @spec to_lower(String.t) :: String.t
  curry to_lower/1
  verify as: String.downcase/1
  def to_lower(a1), do: String.downcase(a1)
  @doc """
  Determine whether *any* characters satisfy a predicate.
  
  
      iex> import Elmchemy.XString
      iex> any.(XChar.is_digit).("90210")
      :true
  
      iex> import Elmchemy.XString
      iex> any.(XChar.is_digit).("R2-D2")
      :true
  
      iex> import Elmchemy.XString
      iex> any.(XChar.is_digit).("heart")
      :false
  
  
 
  """
  @spec any() :: ((char_list -> boolean) -> (String.t -> boolean))
  curry any/2
  def any(f, str) do
    XList.any.(f).(to_list.(str))
  end

  @doc """
  Determine whether *all* characters satisfy a predicate.
  
  
      iex> import Elmchemy.XString
      iex> all.(XChar.is_digit).("90210")
      :true
  
      iex> import Elmchemy.XString
      iex> all.(XChar.is_digit).("R2-D2")
      :false
  
      iex> import Elmchemy.XString
      iex> all.(XChar.is_digit).("heart")
      :false
  
  
 
  """
  @spec all() :: ((char_list -> boolean) -> (String.t -> boolean))
  curry all/2
  def all(f, str) do
    XList.all.(f).(to_list.(str))
  end

  @doc """
  See if the second string contains the first one.
  
  
      iex> import Elmchemy.XString
      iex> contains.("the").("theory")
      :true
  
      iex> import Elmchemy.XString
      iex> contains.("hat").("theory")
      :false
  
      iex> import Elmchemy.XString
      iex> contains.("THE").("theory")
      :false
  
  Use [`Regex.contains`](Regex#contains) if you need something more flexible.
  
  
 
  """
  @spec contains() :: (String.t -> (String.t -> boolean))
  @spec contains(String.t, String.t) :: boolean
  curry contains/2
  def contains(pattern, str) do
    contains_.(str).(pattern)
  end

  @spec contains_() :: (String.t -> (String.t -> boolean))
  @spec contains_(String.t, String.t) :: boolean
  curryp contains_/2
  verify as: String. contains?/2
  def contains_(a1, a2), do: String. contains?(a1, a2)
  @doc """
  See if the second string starts with the first one.
  
  
      iex> import Elmchemy.XString
      iex> starts_with.("the").("theory")
      :true
  
      iex> import Elmchemy.XString
      iex> starts_with.("ory").("theory")
      :false
  
  
 
  """
  @spec starts_with() :: (String.t -> (String.t -> boolean))
  @spec starts_with(String.t, String.t) :: boolean
  curry starts_with/2
  def starts_with(prefix, str) do
    starts_with_.(str).(prefix)
  end

  @spec starts_with_() :: (String.t -> (String.t -> boolean))
  @spec starts_with_(String.t, String.t) :: boolean
  curryp starts_with_/2
  verify as: String.starts_with?/2
  def starts_with_(a1, a2), do: String.starts_with?(a1, a2)
  @doc """
  See if the second string ends with the first one.
  
  
      iex> import Elmchemy.XString
      iex> ends_with.("the").("theory")
      :false
  
      iex> import Elmchemy.XString
      iex> ends_with.("ory").("theory")
      :true
  
  
 
  """
  @spec ends_with() :: (String.t -> (String.t -> boolean))
  @spec ends_with(String.t, String.t) :: boolean
  curry ends_with/2
  def ends_with(suffix, str) do
    ends_with_.(str).(suffix)
  end

  @spec ends_with_() :: (String.t -> (String.t -> boolean))
  @spec ends_with_(String.t, String.t) :: boolean
  curryp ends_with_/2
  verify as: String.ends_with?/2
  def ends_with_(a1, a2), do: String.ends_with?(a1, a2)
  @doc """
  Get all of the indexes for a substring in another string.
  
  
      iex> import Elmchemy.XString
      iex> indexes.("i").("Mississippi")
      [1, 4, 7, 10]
  
      iex> import Elmchemy.XString
      iex> indexes.("ss").("Mississippi")
      [2, 5]
  
      iex> import Elmchemy.XString
      iex> indexes.("needle").("haystack")
      []
  
  
 
  """
  @spec indexes() :: (String.t -> (String.t -> list(integer)))
  @spec indexes(String.t, String.t) :: list(integer)
  curry indexes/2
  def indexes(pattern, str) do
    matches_.(str).(pattern)
    |> (XList.map.(XTuple.first)).()
  end

  @spec matches_() :: (String.t -> (any -> list({integer, String.t})))
  @spec matches_(String.t, any) :: list({integer, String.t})
  curryp matches_/2
  verify as: :binary.matches/2
  def matches_(a1, a2), do: :binary.matches(a1, a2)
  @doc """
  Alias for `indexes`.
  
 
  """
  @spec indices() :: (String.t -> (String.t -> list(integer)))
  @spec indices(String.t, String.t) :: list(integer)
  curry indices/2
  def indices(pattern, str) do
    indexes.(pattern).(str)
  end

  @doc """
  Try to convert a string into an int, failing on improperly formatted strings.
  
  
      iex> import Elmchemy.XString
      iex> XString.to_int.("123")
      {:ok, 123}
  
      iex> import Elmchemy.XString
      iex> XString.to_int.("-42")
      {:ok, -42}
  
      iex> import Elmchemy.XString
      iex> XString.to_int.("3.1")
      {:error, "could not convert string '3.1' to an Int"}
  
      iex> import Elmchemy.XString
      iex> XString.to_int.("31a")
      {:error, "could not convert string '31a' to an Int"}
  
  If you are extracting a number from some raw user input, you will typically
  want to use [`Result.withDefault`](Result#withDefault) to handle bad data:
  
  
      iex> import Elmchemy.XString
      iex> XResult.with_default.(0).(XString.to_int.("42"))
      42
  
      iex> import Elmchemy.XString
      iex> XResult.with_default.(0).(XString.to_int.("ab"))
      0
  
  
 
  """
  @spec to_int() :: (String.t -> Elmchemy.XResult.result)
  @spec to_int(String.t) :: Elmchemy.XResult.result
  curry to_int/1
  def to_int(str) do
    case to_int_.(str) do
      {:error, "argument error"} -> {:error, "could not convert string '" ++ str ++ "' to an Int"}
      e -> e
    end
  end

  @spec to_int_() :: (String.t -> Elmchemy.XResult.result)
  @spec to_int_(String.t) :: Elmchemy.XResult.result
  curryp to_int_/1
  def to_int_(a1) do 
    try_catch fn -> 
      String.to_integer(a1)
    end
  end
  @doc """
  Try to convert a string into a float, failing on improperly formatted strings.
  
  
      iex> import Elmchemy.XString
      iex> XString.to_float.("123")
      {:ok, 123.0}
  
      iex> import Elmchemy.XString
      iex> XString.to_float.("-42")
      {:ok, -42.0}
  
      iex> import Elmchemy.XString
      iex> XString.to_float.("3.1")
      {:ok, 3.1}
  
      iex> import Elmchemy.XString
      iex> XString.to_float.("31a")
      {:error, "could not convert string '31a' to a Float"}
  
  If you are extracting a number from some raw user input, you will typically
  want to use [`Result.withDefault`](Result#withDefault) to handle bad data:
  
  
      iex> import Elmchemy.XString
      iex> XResult.with_default.(0).(XString.to_float.("42.5"))
      42.5
  
      iex> import Elmchemy.XString
      iex> XResult.with_default.(0).(XString.to_float.("cats"))
      0
  
  
 
  """
  @spec to_float() :: (String.t -> Elmchemy.XResult.result)
  @spec to_float(String.t) :: Elmchemy.XResult.result
  curry to_float/1
  def to_float(str) do
    real = if contains.(".").(str) do str else str ++ ".0" end
    case to_float_.(real) do
      {:error, "argument error"} -> {:error, "could not convert string '" ++ str ++ "' to a Float"}
      e -> e
    end
  end

  @spec to_float_() :: (String.t -> Elmchemy.XResult.result)
  @spec to_float_(String.t) :: Elmchemy.XResult.result
  curryp to_float_/1
  def to_float_(a1) do 
    try_catch fn -> 
      String.to_float(a1)
    end
  end
  @doc """
  Convert a string to a list of characters.
  
  
      iex> import Elmchemy.XString
      iex> to_list.("abc")
      ['a', 'b', 'c']
  
  
 
  """
  @spec to_list() :: (String.t -> list(char_list))
  @spec to_list(String.t) :: list(char_list)
  curry to_list/1
  def to_list(str) do
    charlist = to_charlist_.(str)
    map_.(charlist).(XList.singleton)
  end

  #  It's ugly but it's the only way since there's no
  #    Chars in Elixir

  @spec to_charlist_() :: (String.t -> list(integer))
  @spec to_charlist_(String.t) :: list(integer)
  curryp to_charlist_/1
  verify as: String.to_charlist/1
  def to_charlist_(a1), do: String.to_charlist(a1)
  @spec map_() :: (list(integer) -> ((integer -> list(integer)) -> list(char_list)))
  @spec map_(list(integer), (integer -> list(integer))) :: list(char_list)
  curryp map_/2
  def map_(a1, a2), do: Enum.map(a1, fn (x1) -> a2.(x1) end)
  @doc """
  Convert a list of characters into a String. Can be useful if you
  want to create a string primarily by consing, perhaps for decoding
  something.
  
  
      iex> import Elmchemy.XString
      iex> from_list.(['a', 'b', 'c'])
      "abc"
  
  
 
  """
  @spec from_list() :: (list(char_list) -> String.t)
  @spec from_list(list(char_list)) :: String.t
  curry from_list/1
  def from_list(list) do
    join_chars_.(list).("")
  end

  @spec join_chars_() :: (list(char_list) -> (String.t -> String.t))
  @spec join_chars_(list(char_list), String.t) :: String.t
  curryp join_chars_/2
  verify as: Enum.join/2
  def join_chars_(a1, a2), do: Enum.join(a1, a2)
end
>>>>elm/../elm-stuff/packages/wende/elmchemy-core/1.2.0/src/Elmchemy/XTuple.elm
# Compiled using Elmchemy v0.3.7
defmodule Elmchemy.XTuple do
  use Elmchemy

  @doc """
 
  Module for tuple manipulation
  
  @docs first, second, mapFirst, mapSecond
  
 
  """
  @doc """
  Extract the first value from a tuple.
  
  
      iex> import Elmchemy.XTuple
      iex> first.({3, 4})
      3
  
      iex> import Elmchemy.XTuple
      iex> first.({"john", "doe"})
      "john"
  
 
  """
  @spec first() :: ({any, any} -> any)
  @spec first({any, any}) :: any
  curry first/1
  def first({fst, _}) do
    fst
  end

  @doc """
  Extract the second value from a tuple.
  
  
      iex> import Elmchemy.XTuple
      iex> second.({3, 4})
      4
  
      iex> import Elmchemy.XTuple
      iex> second.({"john", "doe"})
      "doe"
  
 
  """
  @spec second() :: ({any, any} -> any)
  @spec second({any, any}) :: any
  curry second/1
  def second({_, snd}) do
    snd
  end

  @doc """
  Transform the first value in a tuple.
  
  
      iex> import Elmchemy.XTuple
      iex> map_first.(XString.reverse).({"stressed", 16})
      {"desserts", 16}
  
      iex> import Elmchemy.XTuple
      iex> map_first.(XString.length).({"stressed", 16})
      {8, 16}
  
 
  """
  @spec map_first() :: ((any -> any) -> ({any, any} -> {any, any}))
  @spec map_first((any -> any), {any, any}) :: {any, any}
  curry map_first/2
  def map_first(f, {fst, snd}) do
    {f.(fst), snd}
  end

  @doc """
  Transform the second value in a tuple.
  
  
      iex> import Elmchemy.XTuple
      iex> map_second.(sqrt).({"stressed", 16})
      {"stressed", 4.0}
  
      iex> import Elmchemy.XTuple
      iex> map_second.(fn(x) -> x + 1 end).({"stressed", 16})
      {"stressed", 17}
  
 
  """
  @spec map_second() :: ((any -> any) -> ({any, any} -> {any, any}))
  @spec map_second((any -> any), {any, any}) :: {any, any}
  curry map_second/2
  def map_second(f, {fst, snd}) do
    {fst, f.(snd)}
  end

end
